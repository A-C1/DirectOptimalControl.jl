var documenterSearchIndex = {"docs":
[{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"# include(\"../src/DirectOptimalControl.jl\")\n# import .DirectOptimalControl as DOC\n\nimport DirectOptimalControl as DOC\nimport Ipopt\nusing JuMP\nusing Interpolations","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"Common parameters","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"vm = 2.0   # Max forward speed\num = 1.0   # Max turning speed\nns = 3     # Number of states\nnu = 2     # Number of inputs\nn = 100    # Time steps\n\nstate_e0 = [0.0, 7.0, -π/2]\nN = 200\nl = 0.05\nδt = 0.1\ntimeE = LinRange(0, N * δt, N)\n\nse = zeros(3, length(timeE))\nse[:,1] = state_e0\nfor i = 1:(length(timeE)-1)\n    se[:, i+1] = se[:, i] + [0.05, 0.05, 0.05]\nend\nx_e = se[1,:]\ny_e = se[2,:]\nth_e = se[3,:]\n\n\nfunction xval(tf)\n    #global δt, timeE, x_e, n\n    interp = LinearInterpolation(timeE, x_e, extrapolation_bc = x_e[N])\n    return interp(tf)\nend\n\nfunction yval(tf)\n    #global δt, timeE, y_e, n\n    interp = LinearInterpolation(timeE, y_e, extrapolation_bc=y_e[N])\n    return interp(tf)\nend","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"System dynamics","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"function dyn(x, u, t, p)","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"vm = p.vm","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"    return [u[2] * cos(x[3]), u[2] * sin(x[3]), u[1]]\nend","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"Objective Function Running cost","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"function L(x, u, t, p)\n    return 1.0\nend\n\nfunction phi(xf, uf, tf, p)\n    return 0.0\nend\n\nfunction integralfun(x, u, t, p)\n    return nothing\nend\n\nfunction pathfun(x, u, t, p)\n    return nothing\nend\n\n\nOC = DOC.OCP()\nOC.tol = 1e-5\nOC.mesh_iter_max = 5\nOC.objective_sense = \"Min\"\nset_optimizer(OC.model, Ipopt.Optimizer)\nset_attribute(OC.model, \"linear_solver\", \"mumps\")\nset_attribute(OC.model, \"print_level\", 0)\n# set_attribute(OC.model, \"max_iter\", 500)\n# set_attribute(OC.model, \"tol\", 1e-6)\n\n@operator(OC.model, op_xval, 1, xval)\n@operator(OC.model, op_yval, 1, yval)","category":"page"},{"location":"dubins_interception.html#Phase-1","page":"Dubins Interception","title":"Phase 1","text":"","category":"section"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"ph = DOC.PH(OC)\nph.L = L\nph.phi = phi\nph.dyn = dyn\nph.integralfun = integralfun\nph.collocation_method = \"hermite-simpson\"\nph.scale_flag = true\n\nph.n = n\nph.ns = ns\nph.nu = nu\nph.nq = 0\nph.nk = 0","category":"page"},{"location":"dubins_interception.html#Auxillary-parameters","page":"Dubins Interception","title":"Auxillary parameters","text":"","category":"section"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"ph.p = (k1 = 1.0, k2 = 2.0)\n\nph.limits.ll.u = [-1.0, 0.75*vm]\nph.limits.ul.u = [1.0, vm]\nph.limits.ll.x = [-30.0, -30.0, -10.0]\nph.limits.ul.x = [30.0, 30.0, 10.0]\nph.limits.ll.xf = [-30.0, -30.0, -10.0]\nph.limits.ul.xf = [30.0, 30.0, 10.0]\nph.limits.ll.xi = [0, 0, -π / 2]\nph.limits.ul.xi = [0, 0, -π / 2]\nph.limits.ll.ti = 0.0\nph.limits.ul.ti = 0.0\nph.limits.ll.tf = 5.0\nph.limits.ul.tf = 15.0\nph.limits.ll.dt = 5.0\nph.limits.ul.dt = 15.0\nph.limits.ll.k = []\nph.limits.ul.k = []","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"ph.setinitialvalues can take two values: \"Auto\" and \"User\" Set initial values","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"ph.set_initial_vals = \"Auto\"","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"Add the boundary constraints","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"function psi(ocp::DOC.OCP)\n    (;ph) = ocp\n\n    # # Phase 1\n    # v1 = ph[1].ti - 0.0\n    # v2 = ph[1].xf - ph[1].p.xfref\n    # v3 = ph[1].xi - ph[1].p.x0\n\n    # # Phase 2\n    v4 = ph[2].ti - ph[1].tf\n    # v5 = ph[2].xi - ph[1].xf\n    # v6 = ph[2].xf - [-5, 5, 0.0]\n\n    # # Phase 3\n    v7 = ph[3].ti - ph[2].tf\n    # v8 = ph[3].xi - ph[2].xf\n    # v9 = ph[3].xf - [-5, -5, 0.0]\n\n    # # Phase 4\n    v10 = ph[4].ti - ph[3].tf\n    # v11 = ph[4].xi - ph[3].xf\n    # v12 = ph[4].xf - ph[4].p.x0\n\n    # return [v1; v2; v3; v4; v5; v6; v7; v8; v9; v10; v11; v12]#; v13; v14; v15]\n    # return [v4, v7, v10]\n    return nothing\nend\n\nOC.psi = psi\nOC.npsi = 0\nOC.set_obj_lim = true\nOC.obj_llim = 5.0\nOC.obj_ulim = 17.0\nOC.psi_llim = []\nOC.psi_ulim = []\nDOC.setup_mpocp(OC)\n\n# Final conditions\nfunction additional_constraints(ph, OC)\n    @constraint(OC.model, (ph.xf[1] - op_xval(ph.tf))^2 + (ph.xf[2] - op_yval(ph.tf))^2 <= l * l)\nend\nOC.additional_constraints = additional_constraints","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"This function needs to be called for single use","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"OC.additional_constraints(ph, OC)\nDOC.solve_mpocp(OC)","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"DOC.solve(OC) Solve for the control and state","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"solution_summary(OC.model)","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"Display results","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"println(\"Min time: \", objective_value(OC.model))\n\n\n# using GLMakie\n# f1, ax1, l1 = lines(value.(ph.x[1, :]), value.(ph.x[2, :]))\n# lines!(ax1, x_e, y_e)\n# ax1.autolimitaspect = 1.0\n# # f1\n# f2, ax2, l21 = lines(value.(ph.t), value.(ph.u[1, :]))\n# f2\n# f3, ax3, l31 = lines(value.(ph.t), value.(ph.u[2, :]))\n# f3","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"","category":"page"},{"location":"dubins_interception.html","page":"Dubins Interception","title":"Dubins Interception","text":"This page was generated using Literate.jl.","category":"page"},{"location":"van_der_pol_oscillator.html#Van-der-Pol-Oscillator","page":"Van Der Pol Oscillator","title":"Van der Pol Oscillator","text":"","category":"section"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"State variables: y_1(t) y_2(t)","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Control variables: u(t).","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Dynamics:  fracd y_1dt = y_2  fracd y_2dt = (1 - y_1^2)y_2 - y_1 + u","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Outputs: No outputs for this problem Objective: Minimize:","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"State Constraints: For this probelem there are no state constraints","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Input Constraints: For this problem there are no input constraints","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Path Constrains: For this problem there are no path constraints","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Integral Constraints: For this problem there are no integral constraints","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Start code Include the necessary packages. JuMP is required to setup various configurations while Ipopt is the solver to be used. Technically all other nonlinear solvers available throught JuMP can be used but those have not yet been tested.","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"# include(\"../src/DirectOptimalControl.jl\")\n# import .DirectOptimalControl as DOC\n\nimport DirectOptimalControl as DOC\n\nusing JuMP\nimport Ipopt","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Let us set first create an optimal control problem. The structure which stores all the data related to the optimal control problem is called OCP (Optimal control problem).","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"OC = DOC.OCP()","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Now we will set various parameters for the solver","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"OC.tol : Sets up tolerence for the solver. In the intial run it is advisable to keep the tolerance high.\nOC.meshitermax : This is the maximum number of iterations that the solver takes\nOC.objective_sense: You can set two options here \"Max\" or \"Min\" depending on weather the objective is to be minimized or maximized","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"OC.tol = 1e-7\nOC.mesh_iter_max = 20\nOC.objective_sense = \"Min\"","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Now it is time to select an optimizer. Let us select the Ipopt optimizer. The OC struct contains an JuMP model in its field OC.model. We can assign any non-linear optimizer that JuMP supports. For this reason we needed to import JuMP. It is advisable to initially keep the solver tolerance higher so that the optimizer converges. You can set all the solver specific options using the JuMP interface to aid the convergence of the solver.","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"set_optimizer(OC.model, Ipopt.Optimizer)\nset_attribute(OC.model, \"print_level\", 0)\n# set_attribute(OC.model, \"max_iter\", 500)\n# set_attribute(OC.model, \"tol\", 1e-4)","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Each OCP must contain atleast one phase. The synatax for adding the phase to an OCP is given by","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"ph = DOC.PH(OC)","category":"page"},{"location":"van_der_pol_oscillator.html#Define-the-models-and-cost-functions","page":"Van Der Pol Oscillator","title":"Define the models and cost functions","text":"","category":"section"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Now let us define the parameters and functions which make up the model","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"y10 = 1                      # Initial height\ny20 = 0                      # Initial velocity\np1 = -0.4\n\nx0 = [y10, y20]           # Initial state\n\nph.nk = 0                               # Number of auxillary phase parameters to be optimized\nph.k = @variable(OC.model, [1:ph.nk])   # Assigne them to field k in struct `ph`\nOC.nkg = 0                              # Number of auxillary global parameters to be optimized\nOC.kg = @variable(OC.model, [1:OC.nkg]) # Assign them to field k in struct `OC`","category":"page"},{"location":"van_der_pol_oscillator.html#Auxillary-parameters","page":"Van Der Pol Oscillator","title":"Auxillary parameters","text":"","category":"section"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Now we create a named tuple of various parameters which will be necessary while defining the problem Note that in addition to the constants defined above we can also pass two additional parameters PH.kp and OC.kg. These are additional JuMP variables which can be optimized if required. They will not be used in this example.","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"p = (p1 = p1, x0 = x0, kp = ph.k, kg = OC.kg )\n\nns = 2\nnu = 1\nn = 20","category":"page"},{"location":"van_der_pol_oscillator.html#System-dynamics","page":"Van Der Pol Oscillator","title":"System dynamics","text":"","category":"section"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Note that the dyn function which defines the dynamics must be in a particular format. It must five inputs: x : The state of system at time t u : The input of system at time t t : The time t p : p is a named tuple of auzillary parameters required to define the fucntion","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"function dyn(x, u, t, p)\n    y1 = x[1]; y2 = x[2];\n    u = u[1]\n\n    y1n = y2\n    y2n = (1-y1^2)*y2 - y1 + u\n\n    return [y1n, y2n]\nend","category":"page"},{"location":"van_der_pol_oscillator.html#Objective-Function","page":"Van Der Pol Oscillator","title":"Objective Function","text":"","category":"section"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"The objective function consists of running cost and a fixed cost. The running cost function also has syntax similar to the dynamics function.","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"function L(x, u, t, p)\n    return u[1]^2 + x[1]^2 + x[2]^2\nend","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"The Final cost function involves the contribution of final state in the objective No final cost is involved","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"function phi(xf, uf, tf, p)\n    return 0.0\nend","category":"page"},{"location":"van_der_pol_oscillator.html#Integral-functions","page":"Van Der Pol Oscillator","title":"Integral functions","text":"","category":"section"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Some of the problems can have integral constraints associated with them in each phase Since this problem does not have an integral constraint the integralfun will return nothing.","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"function integralfun(x, u, t, p)\n    return nothing\nend","category":"page"},{"location":"van_der_pol_oscillator.html#Path-functions","page":"Van Der Pol Oscillator","title":"Path functions","text":"","category":"section"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Some of the problems can have path constraints associated with them in each phase Since this problem does not have an path constraint the pathfun will return nothing.","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"function pathfun(x, u, t, p)\n    y1 = x[1]; y2 = x[2]\n    u = u[1]\n    return -y2 + p.p1\nend\n\nfunction integralfun(x, u, t, p)\n    return nothing\nend","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Now let us assign the various functions defined above to the phase ph that we have created","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"ph.L = L      # Adding the running cost\nph.phi = phi  # Adding the final time cost\nph.dyn = dyn  # Add the dynamics\nph.integralfun = integralfun # Add the integral constraint function\nph.pathfun = pathfun # Add the path constraint function\nph.n = n    # Number of points in initial mesh\nph.ns = ns  # State dimension\nph.nu = nu  # Input dimension\nph.nq = 0   # Dimension of the quadrature (integral) constraint\nph.np = 1   # Dimension of the path constraints\nph.p = p    # Auxillary parametrs named tuple","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Let us select some of the options for the phase","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Collocation method: Two options [\"hermite-simpson\", \"trapezoidal\"]. Default is \"hermite-simpson\"\nScale: Two options true or false","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"ph.collocation_method = \"hermite-simpson\"\nph.scale_flag = true","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Now let us set the upper bounds and lower bounds on all the variables pathconstaints and integral constraints. The upper and lower bounds are defined in the limits field of the PH structure. The limits feild contains ll structure which corrsponds to lower limits. The ul corresponds to upper bounds. The ll and ul structures both contain the JuMP variables on which we wanrt to apply upper and lower bounds. These are: u : Input x : State xf : Final State xi: Initial State tf: Final State ti: Initial time If we want a particular variable to have a fixwd value set both the upper limits and the lower limits to the same value","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"ph.limits.ll.u = [-2.0]      # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.u = [2.0]  # Upper bounds on input. Vector of dimesion `nu`\nph.limits.ll.x = [-2.0, -2.0] # Lower bounds on state trajectory. Vector of dimension `ns`\nph.limits.ul.x = [2.0, 2.0] # Upper bounds on state trajectory. Vector of dimesion `ns`\nph.limits.ll.xf = [-2.0, -2.0]      # Lower bounds on final state. Vector of dimension `nu`\nph.limits.ul.xf = [2.0, 2.0]   # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.xi = p.x0  # Lower bounds on initial state. Vector of dimension `ns`\nph.limits.ul.xi = p.x0  # Upper bounds on initial state. Vector of dimesion `ns`\nph.limits.ll.ti = 0.0   # Lower bounds on initial time. A Scalar.\nph.limits.ul.ti = 0.0   # Upper bounds on initial time. A Scalar\nph.limits.ll.tf = 5.0   # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.tf = 5.0   # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.dt = 0.0     # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.dt = 5.0     # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.k = [] # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.k = [] # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.path = [-10.0]\nph.limits.ul.path = [0.0]","category":"page"},{"location":"van_der_pol_oscillator.html#Set-intial-values","page":"Van Der Pol Oscillator","title":"Set intial values","text":"","category":"section"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"There are two options here \"Auto\" and \"Manual\". If \"Auto\" option is selected one need not specify tau and other init values","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"ph.set_initial_vals = \"Auto\"\nph.tau = range(start = 0, stop = 1, length = ph.n)\nph.xinit = ones(ph.ns, ph.n)\nph.uinit = ones(ph.nu, ph.n)\nph.tfinit = ph.limits.ll.tf\nph.tiinit = ph.limits.ll.ti\nph.kinit  = (ph.limits.ll.k + ph.limits.ul.k)/2","category":"page"},{"location":"van_der_pol_oscillator.html#Specify-global-parameters","page":"Van Der Pol Oscillator","title":"Specify global parameters","text":"","category":"section"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"This problem only contains a single phase. However, in problems with multiple phases there are parameters which are global to all the phases. We specify it here.","category":"page"},{"location":"van_der_pol_oscillator.html#Set-limits-on-objective-function","page":"Van Der Pol Oscillator","title":"Set limits on objective function","text":"","category":"section"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"It has been observed that it is better to not set it as in keep the value false. However, an option is provided to set upper and lower values for the objective function","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"OC.set_obj_lim = false\nOC.obj_llim = -2.0\nOC.obj_ulim = 2.0","category":"page"},{"location":"van_der_pol_oscillator.html#Setting-up-global-parameters","page":"Van Der Pol Oscillator","title":"Setting up global parameters","text":"","category":"section"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"OC.nkg: Number of global parameters\nOC.kg_llim: Lower bound on global parameters\nOC.kg_ulim: Upper bound on global parameters","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Note that these have to be passed to the function through the auxillary parameters tupple p","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"OC.kg_llim = []\nOC.kg_ulim = []","category":"page"},{"location":"van_der_pol_oscillator.html#Setting-up-the-event-function","page":"Van Der Pol Oscillator","title":"Setting up the event function","text":"","category":"section"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"*OC.npsi: Number of constraints in event function *OC.psi_llim: Lower bound on constraint function *OC.psi_ulim: Upper bound on constraint function *OC.psi : Function which contains the event constraints","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"OC.npsi = 0\nOC.psi_llim = []\nOC.psi_ulim = []","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Not the format of he event function psi. It takes the OCP object as input. The OCP object has all the phases stored in it in the field OC.ph. Each phase has state variables which can be accessed by ph.x and input variable which can be accessed by ph.u. In this problem we want that u must have a zero value at end of the phase.","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"function psi(ocp::DOC.OCP)\n    (;ph) = ocp\n\n    return nothing\nend\nOC.psi = psi","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Call function to setup the JuMP model for solving optimal control problem","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"DOC.setup_mpocp(OC)","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Solve for the control and state","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"DOC.solve_mpocp(OC)","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"DOC.solve(OC)","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"solution_summary(OC.model)","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Compute co-states","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"lambda = DOC.differential_constraints_adjoints(ph, OC)\nmu = DOC.path_constraint_adjoints(ph, OC)","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"Display results","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"println(\"Objective Value: \", objective_value(OC.model))\n\n# using GLMakie\n# f = Figure()\n# ax1 = Axis(f[1,1])\n# lines!(ax1, value.(ph.t), value.(ph.x[1,:]))\n# ax2 = Axis(f[2,1])\n# lines!(ax2, value.(ph.t), value.(ph.x[2,:]))\n# # ax3 = Axis(f[1, 2])\n# # lines!(ax3, value.(ph.t), value.(ph.x[3,:]))\n# ax4 = Axis(f[2, 2])\n# lines!(ax4,value.(ph.t), value.(ph.u[1,:]))\n# display(f)\n\n# fl = Figure()\n# ax1 = Axis(fl[1,1])\n# lines!(ax1, value.(ph.t[1:end-1]) ,lambda[1,:])\n# ax2 = Axis(fl[2,1])\n# lines!(ax2, value.(ph.t[1:end-1]) ,lambda[2,:])\n\n# fmu = Figure()\n# axmu = Axis(fmu[1,1])\n# lines!(axmu, value.(ph.t), mu[1,:])","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"","category":"page"},{"location":"van_der_pol_oscillator.html","page":"Van Der Pol Oscillator","title":"Van Der Pol Oscillator","text":"This page was generated using Literate.jl.","category":"page"},{"location":"rocket copy.html#Goddard's-rocket-Model","page":"-","title":"Goddard's rocket Model","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"State variables:","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Velocity: x_v(t)\nAltitude: x_h(t)\nMass of rocket and remaining fuel, x_m(t)","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Control variables","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Thrust: u_t(t).","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Dynamics:","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Rate of ascent: fracd x_hdt = x_v\nAcceleration: fracd x_vdt = fracu_t - D(x_h x_v)x_m - g(x_h)\nRate of mass loss: fracd x_mdt = -fracu_tc","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"where drag D(x_h x_v) is a function of altitude and velocity, gravity g(x_h) is a function of altitude, and c is a constant. These forces are defined as: D(x_h x_v) = D_c cdot x_v^2 cdot e^-h_c left( fracx_h-x_h(0)x_h(0) right) g(x_h) = g_0 cdot left( fracx_h(0)x_h right)^2","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Outputs:","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Objective: Maximize x_h(T).","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"State Constraints: For this probelem there are no state constraints","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Input Constraints: For this problem there are no input constraints","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Path Constrains: For this problem there are no path constraints","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Integral Constraints: For this problem there are no integral constraints","category":"page"},{"location":"rocket copy.html#Start-code","page":"-","title":"Start code","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"Include the necessary packages. JuMP is required to setup various configurations while Ipopt is the solver to be used. Technically all other nonlinear solvers available throught JuMP can be used but those have not yet been tested.","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"# include(\"../src/DirectOptimalControl.jl\")\n# import .DirectOptimalControl as DOC\nimport DirectOptimalControl as DOC\nusing JuMP\nimport Ipopt","category":"page"},{"location":"rocket copy.html#Set-solver-configuration","page":"-","title":"Set solver configuration","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"Let us set first create an optimal control problem. The structure which stores all the data related to the optimal control problem is called OCP (Optimal control problem).","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"OC = DOC.OCP()","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Now we will set various parameters for the solver","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"OC.tol : Sets up tolerence for the solver. In the intial run it is advisable to keep the tolerance high.\nOC.meshitermax : This is the maximum number of iterations that the solver takes\nOC.objective_sense: You can set two options here \"Max\" or \"Min\" depending on weather the objective is to be minimized or maximized","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"OC.tol = 1e-7\nOC.mesh_iter_max = 10\nOC.objective_sense = \"Max\"","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Now it is time to select an optimizer. Let us select the Ipopt optimizer. The OC struct contains an JuMP model in its field OC.model. We can assign any non-linear optimizer that JuMP supports. For this reason we needed to import JuMP. It is advisable to initially keep the solver tolerance higher so that the optimizer converges. You can set all the solver specific options using the JuMP interface to aid the convergence of the solver.","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"set_optimizer(OC.model, Ipopt.Optimizer)\nset_attribute(OC.model, \"print_level\", 0)\n# set_attribute(OC.model, \"max_iter\", 500)\n# set_attribute(OC.model, \"tol\", 1e-4)","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Each OCP must contain atleast one phase. The synatax for adding the phase to an OCP is given by","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"ph = DOC.PH(OC)","category":"page"},{"location":"rocket copy.html#Define-the-models-and-cost-functions","page":"-","title":"Define the models and cost functions","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"Now let us define the parameters and functions which make up the model","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"h0 = 1                      # Initial height\nv0 = 0                      # Initial velocity\nm0 = 1.0                    # Initial mass\nmT = 0.6                    # Final mass\ng0 = 1                      # Gravity at the surface\nhc = 500                    # Used for drag\nc = 0.5 * sqrt(g0 * h0)     # Thrust-to-fuel mass\nDc = 0.5 * 620 * m0 / g0    # Drag scaling\nutmax = 3.5 * g0 * m0       # Maximum thrust\nTmax = 0.2                  # Number of seconds\n\nx0 = [h0, v0, m0]           # Initial state\n\nph.nk = 0                               # Number of auxillary phase parameters to be optimized\nph.k = @variable(OC.model, [1:ph.nk])   # Assigne them to field k in struct `ph`\nOC.nkg = 0                              # Number of auxillary global parameters to be optimized\nOC.kg = @variable(OC.model, [1:OC.nkg]) # Assign them to field k in struct `OC`","category":"page"},{"location":"rocket copy.html#Auxillary-parameters","page":"-","title":"Auxillary parameters","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"Now we create a named tuple of various parameters which will be necessary while defining the problem Note that in addition to the constants defined above we can also pass two additional parameters PH.kp and OC.kg. These are additional JuMP variables which can be optimized if required. They will not be used in this example.","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"p = (g0 = g0, hc = hc, c = c, Dc = Dc, xh0 = h0, utmax = utmax, x0 = x0, kp = ph.k, kg = OC.kg )\n\nns = 3\nnu = 1\nn = 20","category":"page"},{"location":"rocket copy.html#System-dynamics","page":"-","title":"System dynamics","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"Note that the dyn function which defines the dynamics must be in a particular format. It must five inputs: x : The state of system at time t u : The input of system at time t t : The time t p : p is a named tuple of auzillary parameters required to define the fucntion","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"D(xh, xv, p) = p.Dc*(xv^2)*exp(-p.hc*(xh - p.xh0)/p.xh0)\ng(xh, p) = p.g0*(p.xh0/xh)^2\nfunction dyn(x, u, t, p)\n    xhn = x[2]\n    xvn = (u[1] - D(x[1], x[2], p))/x[3] - g(x[1], p)\n    xmn = -u[1]/p.c\n    return [xhn, xvn, xmn]\nend","category":"page"},{"location":"rocket copy.html#Objective-Function","page":"-","title":"Objective Function","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"The objective function consists of running cost and a fixed cost. The running cost function also has syntax similar to the dynamics function. For the rocket example there is no running cost involved so the running cost function returns 0.","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"function L(x, u, t, p)\n    return 0.0\nend","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"The Final cost function involves the contribution of final state in the objective Since we want to maximize the final height the function returns xf[1]. This is because the first state denotes the height as per our definition of the heigth function.","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"function phi(xf, uf, tf, p)\n    return xf[1]\nend","category":"page"},{"location":"rocket copy.html#Integral-functions","page":"-","title":"Integral functions","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"Some of the problems can have integral constraints associated with them in each phase Since this problem does not have an integral constraint the integralfun will return nothing.","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"function integralfun(x, u, t, p)\n    return nothing\nend","category":"page"},{"location":"rocket copy.html#Path-functions","page":"-","title":"Path functions","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"Some of the problems can have path constraints associated with them in each phase Since this problem does not have an path constraint the pathfun will return nothing.","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"function pathfun(x, u, t, p)\n    return nothing\nend","category":"page"},{"location":"rocket copy.html#Adding-functions-and-parameters-to-a-Phase","page":"-","title":"Adding functions and parameters to a Phase","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"Now let us assign the various functions defined above to the phase ph that we have created","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"ph.L = L      # Adding the running cost\nph.phi = phi  # Adding the final time cost\nph.dyn = dyn  # Add the dynamics\nph.integralfun = integralfun # Add the integral constraint function\nph.pathfun = pathfun # Add the path constraint function\nph.n = n    # Number of points in initial mesh\nph.ns = ns  # State dimension\nph.nu = nu  # Input dimension\nph.nq = 0   # Dimension of the quadrature (integral) constraint\nph.np = 0   # Dimension of the path constraints\nph.p = p    # Auxillary parametrs named tuple","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Let us select some of the options for the phase","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Collocation method: Two options [\"hermite-simpson\", \"trapezoidal\"]. Default is \"hermite-simpson\"\nScale: Two options true or false","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"ph.collocation_method = \"hermite-simpson\"\nph.scale_flag = true","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Now let us set the upper bounds and lower bounds on all the variables pathconstaints and integral constraints. The upper and lower bounds are defined in the limits field of the PH structure. The limits feild contains ll structure which corrsponds to lower limits. The ul corresponds to upper bounds. The ll and ul structures both contain the JuMP variables on which we wanrt to apply upper and lower bounds. These are: u : Input x : State xf : Final State xi: Initial State tf: Final State ti: Initial time If we want a particular variable to have a fixwd value set both the upper limits and the lower limits to the same value","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"ph.limits.ll.u = [0.0]      # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.u = [p.utmax]  # Upper bounds on input. Vector of dimesion `nu`\nph.limits.ll.x = [0.0, 0.0, 0.0] # Lower bounds on state trajectory. Vector of dimension `ns`\nph.limits.ul.x = [2.0, 2.0, 2.0] # Upper bounds on state trajectory. Vector of dimesion `ns`\nph.limits.ll.xf = [0.3, 0, mT]      # Lower bounds on final state. Vector of dimension `nu`\nph.limits.ul.xf = [2.0, 2.0, 2.0]   # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.xi = p.x0  # Lower bounds on initial state. Vector of dimension `ns`\nph.limits.ul.xi = p.x0  # Upper bounds on initial state. Vector of dimesion `ns`\nph.limits.ll.ti = 0.0   # Lower bounds on initial time. A Scalar.\nph.limits.ul.ti = 0.0   # Upper bounds on initial time. A Scalar.\nph.limits.ll.tf = 0.2   # Lower bounds on final time. A scalar.\nph.limits.ul.tf = 0.2   # Upper bounds on final time. A scalar.\nph.limits.ll.dt = 0.0     # Lower bounds on time interval. A scalar.\nph.limits.ul.dt = 0.2     # Upper bounds on time interval. A scalar\nph.limits.ll.path = [] # Lower bounds on path constraint. Vector of dimension `nu`\nph.limits.ul.path = [] # Upper bounds on  path constraint. Vector of dimesion `ns`\nph.limits.ll.integral = [] # Lower bounds on integral constraint. Vector of dimension `nu`\nph.limits.ul.integral = [] # Upper bounds on integral contsraint. Vector of dimesion `ns`\nph.limits.ll.k = [] # Lower bounds on phase parameters. Vector of dimension `nu`\nph.limits.ul.k = [] # Upper bounds on phase parameters. Vector of dimesion `ns`","category":"page"},{"location":"rocket copy.html#Set-intial-values","page":"-","title":"Set intial values","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"There are two options here \"Auto\" and \"Manual\". If \"Auto\" option is selected one need not specify tau and other init values","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"ph.set_initial_vals = \"Auto\"\nph.tau = range(start = 0, stop = 1, length = ph.n)\nph.xinit = ones(ph.ns, ph.n)\nph.uinit = ones(ph.nu, ph.n)\nph.tfinit = ph.limits.ll.tf\nph.tiinit = ph.limits.ll.ti\nph.kinit  = (ph.limits.ll.k + ph.limits.ul.k)/2","category":"page"},{"location":"rocket copy.html#Specify-global-parameters","page":"-","title":"Specify global parameters","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"This problem only contains a single phase. However, in problems with multiple phases there are parameters which are global to all the phases. We specify it here.","category":"page"},{"location":"rocket copy.html#Set-limits-on-objective-function","page":"-","title":"Set limits on objective function","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"It has been observed that it is better to not set it as in keep the value false. However, an option is provided to set upper and lower values for the objective function","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"OC.set_obj_lim = false\nOC.obj_llim = -2.0\nOC.obj_ulim = 2.0","category":"page"},{"location":"rocket copy.html#Setting-up-global-parameters","page":"-","title":"Setting up global parameters","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"OC.nkg: Number of global parameters\nOC.kg_llim: Lower bound on global parameters\nOC.kg_ulim: Upper bound on global parameters","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Note that these have to be passed to the function through the auxillary parameters tupple p","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"OC.kg_llim = []\nOC.kg_ulim = []","category":"page"},{"location":"rocket copy.html#Setting-up-the-event-function","page":"-","title":"Setting up the event function","text":"","category":"section"},{"location":"rocket copy.html","page":"-","title":"-","text":"*OC.npsi: Number of constraints in event function *OC.psi_llim: Lower bound on constraint function *OC.psi_ulim: Upper bound on constraint function *OC.psi : Function which contains the event constraints","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"OC.npsi = 1\nOC.psi_llim = [0.0]\nOC.psi_ulim = [0.0]","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Not the format of he event function psi. It takes the OCP object as input. The OCP object has all the phases stored in it in the field OC.ph. Each phase has state variables which can be accessed by ph.x and input variable which can be accessed by ph.u. In this problem we want that u must have a zero value at end of the phase.","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"function psi(ocp::DOC.OCP)\n    (;ph) = ocp\n\n    v1 = ph[1].u[:, end]\n\n    return [v1;]\nend\nOC.psi = psi","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Callback function can be used to log variables Set it to return nothing if you do not want to log variables in mesh iterations","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"ph.callback_nt = (tau_hist = Vector{Float64}[],err_hist = Vector{Float64}[])\nfunction callback_fun(ph::DOC.PH)\n    push!(ph.callback_nt.tau_hist, deepcopy(ph.tau))\n    push!(ph.callback_nt.err_hist, deepcopy(ph.error))\nend\nph.callback_fun = callback_fun","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Call function to setup the JuMP model for solving optimal control problem","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"DOC.setup_mpocp(OC)","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Solve for the control and state","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"DOC.solve_mpocp(OC)","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"DOC.solve(OC)","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"solution_summary(OC.model)","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"Display results","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"println(\"Objective Value: \", objective_value(OC.model))\n\n# using GLMakie\n# f = Figure()\n# ax1 = Axis(f[1,1])\n# lines!(ax1, value.(ph.t), value.(ph.x[1,:]))\n# ax2 = Axis(f[2,1])\n# lines!(ax2, value.(ph.t), value.(ph.x[2,:]))\n# ax3 = Axis(f[1, 2])\n# lines!(ax3, value.(ph.t), value.(ph.x[3,:]))\n# ax4 = Axis(f[2, 2])\n# lines!(ax4,value.(ph.t), value.(ph.u[1,:]))\n# display(f)\n\n# fth = Figure()\n# axth = Axis(fth[1,1])\n# n = length(ph.callback_nt.tau_hist)\n# for i = 1:n\n#     ni = length(ph.callback_nt.tau_hist[i])\n#     tau = ph.callback_nt.tau_hist[i]\n#     scatter!(axth,tau,i*ones(ni))\n# end\n\n# feh = Figure()\n# axeh = Axis(feh[1,1])\n# n = length(ph.callback_nt.err_hist)\n# for i = 3:n\n#     ni = length(ph.callback_nt.err_hist[i])\n#     err = ph.callback_nt.err_hist[i]\n#     tau = ph.callback_nt.tau_hist[i]\n#     lines!(axeh,tau[1:end-1],err)\n# end","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"","category":"page"},{"location":"rocket copy.html","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"space_craft.html#Goddard's-rocket-Model","page":"Assignement to Phase object","title":"Goddard's rocket Model","text":"","category":"section"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"State variables:","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Velocity: x_v(t)\nAltitude: x_h(t)\nMass of rocket and remaining fuel, x_m(t)","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Control variables","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Thrust: u_t(t).","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Dynamics:","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Rate of ascent: fracd x_hdt = x_v\nAcceleration: fracd x_vdt = fracu_t - D(x_h x_v)x_m - g(x_h)\nRate of mass loss: fracd x_mdt = -fracu_tc","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"where drag D(x_h x_v) is a function of altitude and velocity, gravity g(x_h) is a function of altitude, and c is a constant. These forces are defined as: D(x_h x_v) = D_c cdot x_v^2 cdot e^-h_c left( fracx_h-x_h(0)x_h(0) right) g(x_h) = g_0 cdot left( fracx_h(0)x_h right)^2","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Outputs:","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Objective: Maximize x_h(T).","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"State Constraints:","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Input Constraints:","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Path Constrains:","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Integral Constraints:","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Include the necessary packages. JuMP is required to setup various configurations while Ipopt is the solver to be used. Technically all other nonlinear solvers available throught JuMP can be used but those have not yet been tested.","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"# include(\"../src/DirectOptimalControl.jl\")\n# import .DirectOptimalControl as DOC\n\nimport DirectOptimalControl as DOC\nusing JuMP\nimport Ipopt","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Set solver configuration Let us set first create an optimal control problem. The structure which stores all the data related to the optimal control problem is called OCP (Optimal control problem).","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"OC = DOC.OCP()","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Now we will set various parameters for the solver","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"OC.tol : Sets up tolerence for the solver. In the intial run it is advisable to keep the tolerance high.\nOC.meshitermax : This is the maximum number of iterations that the solver takes\nOC.objective_sense: You can set two options here \"Max\" or \"Min\" depending on weather the objective is to be minimized or maximized","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"OC.tol = 1e-7\nOC.mesh_iter_max = 10\nOC.objective_sense = \"Max\"","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Now it is time to select an optimizer. Let us select the Ipopt optimizer. The OC struct contains an JuMP model in its field OC.model. We can assign any non-linear optimizer that JuMP supports. For this reason we needed to import JuMP. It is advisable to initially keep the solver tolerance higher so that the optimizer converges. You can set all the solver specific options using the JuMP interface to aid the convergence of the solver.","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"set_optimizer(OC.model, Ipopt.Optimizer)\nset_attribute(OC.model, \"print_level\", 0)\nset_attribute(OC.model, \"max_iter\", 500)","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"setattribute(OC.model, \"linearsolver\", \"MA27\") set_attribute(OC.model, \"tol\", 1e-3)","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Each OCP must contain atleast one phase. The synatax for adding the phase to an OCP is given by","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"ph = DOC.PH(OC)","category":"page"},{"location":"space_craft.html#Define-the-models-and-cost-functions","page":"Assignement to Phase object","title":"Define the models and cost functions","text":"","category":"section"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Now let us define the objectives and functions which make up the model","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"cft2m = 0.3048;\ncft2km = cft2m/1000;\ncslug2kg = 14.5939029;","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Provide Auxiliary Data for Problem","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Re = 6371203.92 # Equatorial Radius of Earth (m)\nS = 249.9091776 # Vehicle Reference Area (mˆ2)\ncl = [-0.2070 1.6756] # Parameters for Lift Coefficient\ncdd = [0.0785 -0.3529 2.0400] # Parameters for Drag Coefficient\nb = [0.07854 -0.061592 0.00621408] # Parameters for Heat Rate Model\nH = 7254.24; # Density Scale Height (m)\nal = [-0.20704 0.029244]; # Parameters for Heat Rate Model\nrho0 = 1.225570827014494; # Sea Level Atmospheric Density (kg/mˆ3)\nmu = 3.986031954093051e14; # Earth Gravitational Parameter (mˆ3/sˆ2)\nmass = 92079.2525560557; # Vehicle Mass (kg)\n\np = (Re = Re, S = S, cl = cl, cd = cdd, b = b, H = H, al = al, rho0 = rho0, mu = mu, mass = mass)","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Boundary Conditions","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"t0 = 0\nalt0 = 79248\nrad0 = alt0+Re\naltf = +24384\nradf = altf + Re\nlon0 = 0\nlat0 = 0\nspeed0 = +7802.88\nspeedf = +762\nfpa0 = -1*pi/180\nfpaf = -5*pi/180\nazi0 = +90*pi/180\nazif = -90*pi/180","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Limits on Variables","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"tfMin = 0; tfMax = 3000;\nradMin = Re; radMax = rad0;\nlonMin = -pi; lonMax = -lonMin;\nlatMin = -70*pi/180; latMax = -latMin;\nspeedMin = 10; speedMax = 45000;\nfpaMin = -80*pi/180; fpaMax = 80*pi/180;\naziMin = -180*pi/180; aziMax = 180*pi/180;\naoaMin = -90*pi/180; aoaMax = -aoaMin;\nbankMin = -90*pi/180; bankMax = 1*pi/180;","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Provide Guess of Solution","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"tGuess = [0; 1000];\nradGuess = [rad0; radf];\nlonGuess = [lon0; lon0+10*pi/180];\nlatGuess = [lat0; lat0+10*pi/180];\nspeedGuess = [speed0; speedf];\nfpaGuess = [fpa0; fpaf];\naziGuess = [azi0; azif];\naoaGuess = [0; 0];\nbankGuess = [0; 0];","category":"page"},{"location":"space_craft.html#Auxillary-parameters","page":"Assignement to Phase object","title":"Auxillary parameters","text":"","category":"section"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Now we create a named tuple of various parameters which will be necessary while defining the problem Note that in addition to the constants defined above we also add two additional parameters PH.kp and OC.kg. These are additional JuMP variables which can be optimized if required. They will not be used in this example.","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"ns = 6\nnu = 2\nn = 20","category":"page"},{"location":"space_craft.html#System-dynamics","page":"Assignement to Phase object","title":"System dynamics","text":"","category":"section"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Note that the dyn function which defines the dynamics must be in a particular format. It must five inputs: x : The state of system at time t u : The input of system at time t t : The time t p : p is a named tuple of auzillary parameters required to define the fucntion k : k is a named tuple containing kg and kp","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"function dyn(x, u, t, p)\n    rad = x[1]; lon = x[2]; lat = x[3]; v = x[4]; fpa = x[5]; azi = x[6]\n    aoa = u[1]; bank = u[2]\n\n    cd0 = p.cd[1]\n    cd1 = p.cd[2]\n    cd2 = p.cd[3]\n    cl0 = p.cl[1]\n    cl1 = p.cl[2]\n    mu = p.mu\n    rho0 = p.rho0\n    H = p.H\n    S = p.S\n    mass = p.mass\n    altitude = rad - p.Re\n    CD = cd0 + cd1 * aoa + cd2 * aoa^2\n    rho = rho0 * exp(-altitude / H)\n    CL = cl0 + cl1 * aoa\n    q = 0.5 * rho * v^2\n    D = q * S * CD / mass\n    L = q * S * CL / mass\n    gravity = mu/rad^2\n\n    raddot = v*sin(fpa)\n    londot = v*cos(fpa)*sin(azi)/(rad*cos(lat))\n    latdot = v*cos(fpa)*cos(azi)/rad\n    vdot = -D-gravity*sin(fpa)\n    fpadot = (L*cos(bank)-cos(fpa)*(gravity-v^2/rad))/v;\n    azidot = (L*sin(bank)/cos(fpa)+v^2*cos(fpa)*sin(azi)*tan(lat)/rad)/v;\n\n    return [raddot, londot, latdot, vdot, fpadot, azidot]\nend","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Objective Function The objective function consists of running cost and a fixed cost. The running cost function also has syntax similar to the dynamics function. For the rocket example there is no running cost involved so the running cost function returns 0.","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"function L(x, u, t, p)\n    return 0.0\nend","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"The Final cost function involves the contribution of final state in the objective Since we want to maximize the final height the function returns xf[1]. This is because the first state denotes the height as per our definition of the heigth function.","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"function phi(xf, uf, tf, p)\n    return xf[3]\nend","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Integral functions Some of the problems can have integral constraints associated with them in each phase Since this problem does not have an integral constraint the integralfun will return nothing.","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"function integralfun(x, u, t, p)\n    return nothing\nend","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Path functions Some of the problems can have path constraints associated with them in each phase Since this problem does not have an path constraint the pathfun will return nothing.","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"function pathfun(x, u, t, p)\n    v = x[4]; rad = x[1];\n    aoa = u[1]; bank = u[2]\n\n    return nothing\nend\n\nfunction integralfun(x, u, t, p)\n    return nothing\nend","category":"page"},{"location":"space_craft.html#Assignement-to-Phase-object","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"","category":"section"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Now let us assign the various functions defined above to the phase ph that we have just created","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"ph.L = L      # Adding the running cost\nph.phi = phi  # Adding the final time cost\nph.dyn = dyn  # Add the dynamics\nph.integralfun = integralfun # Add the integral constraint function\nph.pathfun = pathfun # Add the integral constraint function\nph.n = n    # Number of points in initial mesh\nph.ns = ns  # State dimension\nph.nu = nu  # Input dimension\nph.nq = 0   # Dimension of the quadrature (integral) constraint\nph.nk = 0   # Dimension of the optimizable phase paramters\nph.np = 0   # Dimension of the path constraints\nph.p = p    # Auxillary parametrs named tuple","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Let us select some of the options for the phase","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Collocation method: Two options [\"hermite-simpson\", \"trapezoidal\"]. Default is \"hermite-simpson\"\nScale: Two options true or false","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"ph.collocation_method = \"hermite-simpson\"\nph.scale_flag = true","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Now let us set the upper bounds and lower bounds on all the variables pathconstaints and integral constraints. The upper and lower bounds are defined in the limits field of the PH structure. The limits feild contains ll structure which corrsponds to lower limits. The ul corresponds to upper bounds. The ll and ul structures both contain the JuMP variables on which we wanrt to apply upper and lower bounds. These are: u : Input x : State xf : Final State xi: Initial State tf: Final State ti: Initial time If we want a particular variable to have a fixwd value set both the upper limits and the lower limits to the same value","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"ph.limits.ll.u = [aoaMin, bankMin]      # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.u = [aoaMax, bankMax]  # Upper bounds on input. Vector of dimesion `nu`\nph.limits.ll.x =  [radMin, lonMin, latMin, speedMin, fpaMin, aziMin] # Lower bounds on state trajectory. Vector of dimension `ns`\nph.limits.ul.x =  [radMax, lonMax, latMax, speedMax, fpaMax, aziMax] # Upper bounds on state trajectory. Vector of dimesion `ns`\nph.limits.ll.xf =  [radf, lonMin, latMin, speedf, fpaf, aziMin];    # Lower bounds on final state. Vector of dimension `nu`\nph.limits.ul.xf =  [radf, lonMax, latMax, speedf, fpaf, aziMax] # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.xi = [rad0, lon0, lat0, speed0, fpa0, azi0]  # Lower bounds on initial state. Vector of dimension `ns`\nph.limits.ul.xi = [rad0, lon0, lat0, speed0, fpa0, azi0]  # Upper bounds on initial state. Vector of dimesion `ns`\nph.limits.ll.ti = t0   # Lower bounds on initial time. A Scalar.\nph.limits.ul.ti = t0   # Upper bounds on initial time. A Scalar\nph.limits.ll.tf = tfMin   # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.tf = tfMax   # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.dt = tfMin     # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.dt = tfMax     # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.k = [] # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.k = [] # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.path = [] # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.path = [] # Upper bounds on input. Vector of dimesion `ns`","category":"page"},{"location":"space_craft.html#Set-intial-values","page":"Assignement to Phase object","title":"Set intial values","text":"","category":"section"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"There are two options here \"Auto\" and \"Manual\". If \"Auto\" option is selected one need not specify tau and other init values","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"ph.set_initial_vals = \"Auto\"","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"ph.tau = range(start = 0, stop = 1, length = ph.n) ph.xinit = ones(ph.ns, ph.n) ph.uinit = ones(ph.nu, ph.n) ph.tfinit = ph.limits.ll.tf ph.tiinit = ph.limits.ll.ti ph.kinit  = (ph.limits.ll.k + ph.limits.ul.k)/2","category":"page"},{"location":"space_craft.html#Specify-global-parameters","page":"Assignement to Phase object","title":"Specify global parameters","text":"","category":"section"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"This problem only contains a single phase. However, in problems with multiple phases there are parameters which are global to all the phases. We specify it here.","category":"page"},{"location":"space_craft.html#Set-limits-on-objective-function","page":"Assignement to Phase object","title":"Set limits on objective function","text":"","category":"section"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"It has been observed that it is better to not set it as in keep the value false. However, an option is provided to set upper and lower values for the objective function","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"OC.set_obj_lim = false\nOC.obj_llim = -2.0\nOC.obj_ulim = 2.0","category":"page"},{"location":"space_craft.html#Setting-up-global-parameters","page":"Assignement to Phase object","title":"Setting up global parameters","text":"","category":"section"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"OC.nkg: Number of global parameters\nOC.kg_llim: Lower bound on global parameters\nOC.kg_ulim: Upper bound on global parameters","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Note that these have to be passed to the function through the auxillary parameters tupple p","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"OC.nkg = 0\nOC.kg_llim = []\nOC.kg_ulim = []","category":"page"},{"location":"space_craft.html#Setting-up-the-event-function","page":"Assignement to Phase object","title":"Setting up the event function","text":"","category":"section"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"*OC.npsi: Number of constraints in event function *OC.psi_llim: Lower bound on constraint function *OC.psi_ulim: Upper bound on constraint function *OC.psi : Function which contains the event constraints","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"OC.npsi = 0\nOC.psi_llim = []\nOC.psi_ulim = []","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Not the format of he event function psi. It takes the OCP object as input. The OCP object has all the phases stored in it in the field OC.ph. Each phase has state variables which can be accessed by ph.x and input variable which can be accessed by ph.u.","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"function psi(ocp::DOC.OCP)\n    (;ph) = ocp\n\n    return nothing\nend\nOC.psi = psi","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Call function to setup the JuMP model for solving optimal control problem","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"DOC.setup_mpocp(OC)","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Solve for the control and state","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"DOC.solve_mpocp(OC)","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"DOC.solve(OC)","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"solution_summary(OC.model)","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"Display results","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"println(\"Objective Value: \", objective_value(OC.model))\n\n# using GLMakie\n# f = Figure()\n# for i = 1:2:ns\n#     ax = Axis(f[i,1])\n#     lines!(ax, value.(ph.t), value.(ph.x[i,:]))\n#     if i+1 <= ns\n#         ax = Axis(f[i,2])\n#         lines!(ax, value.(ph.t), value.(ph.x[i+1,:]))\n#     end\n# end\n# #     ax2 = Axis(f[2,1])\n# # lines!(ax2, value.(ph.t), value.(ph.x[2,:]))\n# # ax3 = Axis(f[1, 2])\n# # lines!(ax3, value.(ph.t), value.(ph.x[3,:]))\n# # ax4 = Axis(f[2, 2])\n# # lines!(ax4,value.(ph.t), value.(ph.u[1,:]))\n# display(f)","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"","category":"page"},{"location":"space_craft.html","page":"Assignement to Phase object","title":"Assignement to Phase object","text":"This page was generated using Literate.jl.","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"# include(\"../src/DirectOptimalControl.jl\")\n# import .DirectOptimalControl as DOC\n\nimport .DirectOptimalControl as DOC\nimport Ipopt\nusing JuMP\n\n\nOC = DOC.OCP()\nOC.tol = 1e-7\nOC.mesh_iter_max = 30\nOC.objective_sense = \"Min\"\nset_optimizer(OC.model, Ipopt.Optimizer)\n# set_attribute(OC.model, \"max_iter\", 500)\n# set_attribute(OC.model, \"tol\", 1e-3)\nset_attribute(OC.model, \"print_level\", 0)\n\n\nt0 = 0;\ntf = 10000;\nx0 = 1.5;\nxf = 1;\nxMin = -50;\nxMax = +50;\nuMin = -50;\nuMax = +50;\n\nns = 1\nnu = 1\nn = 10","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"System dynamics Function must always return a vector``","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"function dyn(x, u, t, p)\n    return [-x[1]^3 + u[1]]\nend","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"Objective Function Running cost","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"function L(x, u, t, p)\n    return 0.5*(x[1]^2 + u[1]^2)\nend\n\nfunction phi(xf, uf, tf, p)\n    return xf[1]^2 + uf[1]^2\nend\n\nintegralfun(x, u, t, p) = nothing","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"Phase 1","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"ph = DOC.PH(OC)\nph.L = L\nph.phi = phi\nph.dyn = dyn\nph.integralfun = integralfun\n\nph.n = n\nph.ns = ns\nph.nu = nu\nph.p = (k1 = 1, k2 = 2)\n\nph.limits.ll.u = [uMin]\nph.limits.ul.u = [uMax]\nph.limits.ll.x =[xMin]\nph.limits.ul.x = [xMax]\nph.limits.ll.xf = [xf]\nph.limits.ul.xf = [xf]\nph.limits.ll.xi = [x0]\nph.limits.ul.xi = [x0]\nph.limits.ll.ti = t0\nph.limits.ul.ti = t0\nph.limits.ll.tf = tf\nph.limits.ul.tf = tf\nph.limits.ll.dt = tf-t0\nph.limits.ul.dt = tf-t0\n\nph.collocation_method = \"hermite-simpson\"\nph.set_initial_vals = \"Auto\"\nph.scale_flag = true","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"Add the boundary constraints","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"function psi(ocp::DOC.OCP)\n    (;ph) = ocp\n\n    return nothing\nend\n\nOC.psi = psi\nDOC.setup_mpocp(OC)\n# DOC.solve_mpocp(OC)\nDOC.solve(OC)","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"Solve for the control and state","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"solution_summary(OC.model)","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"Display results","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"println(\"Min value: \", objective_value(OC.model))\n\n# using GLMakie\n# f1, ax1, l1 = lines(value.(ph.t), value.(ph.x[1,:]))\n# f2, ax2, l2 = lines(value.(ph.t), value.(ph.u[1,:]))","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"","category":"page"},{"location":"hyper_sensetive_problem.html","page":"Hyper sensetive problem","title":"Hyper sensetive problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"rocket.html#Goddard's-rocket-Model","page":"Rocket Control","title":"Goddard's rocket Model","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"State variables:","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Velocity: x_v(t)\nAltitude: x_h(t)\nMass of rocket and remaining fuel, x_m(t)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Control variables","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Thrust: u_t(t).","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Dynamics:","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Rate of ascent: fracd x_hdt = x_v\nAcceleration: fracd x_vdt = fracu_t - D(x_h x_v)x_m - g(x_h)\nRate of mass loss: fracd x_mdt = -fracu_tc","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"where drag D(x_h x_v) is a function of altitude and velocity, gravity g(x_h) is a function of altitude, and c is a constant. These forces are defined as: D(x_h x_v) = D_c cdot x_v^2 cdot e^-h_c left( fracx_h-x_h(0)x_h(0) right) g(x_h) = g_0 cdot left( fracx_h(0)x_h right)^2","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Outputs:","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Objective: Maximize x_h(T).","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"State Constraints: For this probelem there are no state constraints","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Input Constraints: For this problem there are no input constraints","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Path Constrains: For this problem there are no path constraints","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Integral Constraints: For this problem there are no integral constraints","category":"page"},{"location":"rocket.html#Start-code","page":"Rocket Control","title":"Start code","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Include the necessary packages. JuMP is required to setup various configurations while Ipopt is the solver to be used. Technically all other nonlinear solvers available throught JuMP can be used but those have not yet been tested.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"# include(\"../src/DirectOptimalControl.jl\")\n# import .DirectOptimalControl as DOC\nimport DirectOptimalControl as DOC\nusing JuMP\nimport Ipopt","category":"page"},{"location":"rocket.html#Set-solver-configuration","page":"Rocket Control","title":"Set solver configuration","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Let us set first create an optimal control problem. The structure which stores all the data related to the optimal control problem is called OCP (Optimal control problem).","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"OC = DOC.OCP()","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Now we will set various parameters for the solver","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"OC.tol : Sets up tolerence for the solver. In the intial run it is advisable to keep the tolerance high.\nOC.meshitermax : This is the maximum number of iterations that the solver takes\nOC.objective_sense: You can set two options here \"Max\" or \"Min\" depending on weather the objective is to be minimized or maximized","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"OC.tol = 1e-7\nOC.mesh_iter_max = 10\nOC.objective_sense = \"Max\"","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Now it is time to select an optimizer. Let us select the Ipopt optimizer. The OC struct contains an JuMP model in its field OC.model. We can assign any non-linear optimizer that JuMP supports. For this reason we needed to import JuMP. It is advisable to initially keep the solver tolerance higher so that the optimizer converges. You can set all the solver specific options using the JuMP interface to aid the convergence of the solver.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"set_optimizer(OC.model, Ipopt.Optimizer)\nset_attribute(OC.model, \"print_level\", 0)\n# set_attribute(OC.model, \"max_iter\", 500)\n# set_attribute(OC.model, \"tol\", 1e-4)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Each OCP must contain atleast one phase. The synatax for adding the phase to an OCP is given by","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"ph = DOC.PH(OC)","category":"page"},{"location":"rocket.html#Define-the-models-and-cost-functions","page":"Rocket Control","title":"Define the models and cost functions","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Now let us define the parameters and functions which make up the model","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"h0 = 1                      # Initial height\nv0 = 0                      # Initial velocity\nm0 = 1.0                    # Initial mass\nmT = 0.6                    # Final mass\ng0 = 1                      # Gravity at the surface\nhc = 500                    # Used for drag\nc = 0.5 * sqrt(g0 * h0)     # Thrust-to-fuel mass\nDc = 0.5 * 620 * m0 / g0    # Drag scaling\nutmax = 3.5 * g0 * m0       # Maximum thrust\nTmax = 0.2                  # Number of seconds\n\nx0 = [h0, v0, m0]           # Initial state\n\nph.nk = 0                               # Number of auxillary phase parameters to be optimized\nph.k = @variable(OC.model, [1:ph.nk])   # Assigne them to field k in struct `ph`\nOC.nkg = 0                              # Number of auxillary global parameters to be optimized\nOC.kg = @variable(OC.model, [1:OC.nkg]) # Assign them to field k in struct `OC`","category":"page"},{"location":"rocket.html#Auxillary-parameters","page":"Rocket Control","title":"Auxillary parameters","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Now we create a named tuple of various parameters which will be necessary while defining the problem Note that in addition to the constants defined above we can also pass two additional parameters PH.kp and OC.kg. These are additional JuMP variables which can be optimized if required. They will not be used in this example.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"p = (g0 = g0, hc = hc, c = c, Dc = Dc, xh0 = h0, utmax = utmax, x0 = x0, kp = ph.k, kg = OC.kg )\n\nns = 3\nnu = 1\nn = 20","category":"page"},{"location":"rocket.html#System-dynamics","page":"Rocket Control","title":"System dynamics","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Note that the dyn function which defines the dynamics must be in a particular format. It must five inputs: x : The state of system at time t u : The input of system at time t t : The time t p : p is a named tuple of auzillary parameters required to define the fucntion","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"D(xh, xv, p) = p.Dc*(xv^2)*exp(-p.hc*(xh - p.xh0)/p.xh0)\ng(xh, p) = p.g0*(p.xh0/xh)^2\nfunction dyn(x, u, t, p)\n    xhn = x[2]\n    xvn = (u[1] - D(x[1], x[2], p))/x[3] - g(x[1], p)\n    xmn = -u[1]/p.c\n    return [xhn, xvn, xmn]\nend","category":"page"},{"location":"rocket.html#Objective-Function","page":"Rocket Control","title":"Objective Function","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"The objective function consists of running cost and a fixed cost. The running cost function also has syntax similar to the dynamics function. For the rocket example there is no running cost involved so the running cost function returns 0.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"function L(x, u, t, p)\n    return 0.0\nend","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"The Final cost function involves the contribution of final state in the objective Since we want to maximize the final height the function returns xf[1]. This is because the first state denotes the height as per our definition of the heigth function.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"function phi(xf, uf, tf, p)\n    return xf[1]\nend","category":"page"},{"location":"rocket.html#Integral-functions","page":"Rocket Control","title":"Integral functions","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Some of the problems can have integral constraints associated with them in each phase Since this problem does not have an integral constraint the integralfun will return nothing.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"function integralfun(x, u, t, p)\n    return nothing\nend","category":"page"},{"location":"rocket.html#Path-functions","page":"Rocket Control","title":"Path functions","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Some of the problems can have path constraints associated with them in each phase Since this problem does not have an path constraint the pathfun will return nothing.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"function pathfun(x, u, t, p)\n    return nothing\nend","category":"page"},{"location":"rocket.html#Adding-functions-and-parameters-to-a-Phase","page":"Rocket Control","title":"Adding functions and parameters to a Phase","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Now let us assign the various functions defined above to the phase ph that we have created","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"ph.L = L      # Adding the running cost\nph.phi = phi  # Adding the final time cost\nph.dyn = dyn  # Add the dynamics\nph.integralfun = integralfun # Add the integral constraint function\nph.pathfun = pathfun # Add the path constraint function\nph.n = n    # Number of points in initial mesh\nph.ns = ns  # State dimension\nph.nu = nu  # Input dimension\nph.nq = 0   # Dimension of the quadrature (integral) constraint\nph.np = 0   # Dimension of the path constraints\nph.p = p    # Auxillary parametrs named tuple","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Let us select some of the options for the phase","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Collocation method: Two options [\"hermite-simpson\", \"trapezoidal\"]. Default is \"hermite-simpson\"\nScale: Two options true or false","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"ph.collocation_method = \"hermite-simpson\"\nph.scale_flag = true","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Now let us set the upper bounds and lower bounds on all the variables pathconstaints and integral constraints. The upper and lower bounds are defined in the limits field of the PH structure. The limits feild contains ll structure which corrsponds to lower limits. The ul corresponds to upper bounds. The ll and ul structures both contain the JuMP variables on which we wanrt to apply upper and lower bounds. These are: u : Input x : State xf : Final State xi: Initial State tf: Final State ti: Initial time If we want a particular variable to have a fixwd value set both the upper limits and the lower limits to the same value","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"ph.limits.ll.u = [0.0]      # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.u = [p.utmax]  # Upper bounds on input. Vector of dimesion `nu`\nph.limits.ll.x = [0.0, 0.0, 0.0] # Lower bounds on state trajectory. Vector of dimension `ns`\nph.limits.ul.x = [2.0, 2.0, 2.0] # Upper bounds on state trajectory. Vector of dimesion `ns`\nph.limits.ll.xf = [0.3, 0, mT]      # Lower bounds on final state. Vector of dimension `nu`\nph.limits.ul.xf = [2.0, 2.0, 2.0]   # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.xi = p.x0  # Lower bounds on initial state. Vector of dimension `ns`\nph.limits.ul.xi = p.x0  # Upper bounds on initial state. Vector of dimesion `ns`\nph.limits.ll.ti = 0.0   # Lower bounds on initial time. A Scalar.\nph.limits.ul.ti = 0.0   # Upper bounds on initial time. A Scalar.\nph.limits.ll.tf = 0.2   # Lower bounds on final time. A scalar.\nph.limits.ul.tf = 0.2   # Upper bounds on final time. A scalar.\nph.limits.ll.dt = 0.0     # Lower bounds on time interval. A scalar.\nph.limits.ul.dt = 0.2     # Upper bounds on time interval. A scalar\nph.limits.ll.path = [] # Lower bounds on path constraint. Vector of dimension `nu`\nph.limits.ul.path = [] # Upper bounds on  path constraint. Vector of dimesion `ns`\nph.limits.ll.integral = [] # Lower bounds on integral constraint. Vector of dimension `nu`\nph.limits.ul.integral = [] # Upper bounds on integral contsraint. Vector of dimesion `ns`\nph.limits.ll.k = [] # Lower bounds on phase parameters. Vector of dimension `nu`\nph.limits.ul.k = [] # Upper bounds on phase parameters. Vector of dimesion `ns`","category":"page"},{"location":"rocket.html#Set-intial-values","page":"Rocket Control","title":"Set intial values","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"There are two options here \"Auto\" and \"Manual\". If \"Auto\" option is selected one need not specify tau and other init values","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"ph.set_initial_vals = \"Auto\"\nph.tau = range(start = 0, stop = 1, length = ph.n)\nph.xinit = ones(ph.ns, ph.n)\nph.uinit = ones(ph.nu, ph.n)\nph.tfinit = ph.limits.ll.tf\nph.tiinit = ph.limits.ll.ti\nph.kinit  = (ph.limits.ll.k + ph.limits.ul.k)/2","category":"page"},{"location":"rocket.html#Specify-global-parameters","page":"Rocket Control","title":"Specify global parameters","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"This problem only contains a single phase. However, in problems with multiple phases there are parameters which are global to all the phases. We specify it here.","category":"page"},{"location":"rocket.html#Set-limits-on-objective-function","page":"Rocket Control","title":"Set limits on objective function","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"It has been observed that it is better to not set it as in keep the value false. However, an option is provided to set upper and lower values for the objective function","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"OC.set_obj_lim = false\nOC.obj_llim = -2.0\nOC.obj_ulim = 2.0","category":"page"},{"location":"rocket.html#Setting-up-global-parameters","page":"Rocket Control","title":"Setting up global parameters","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"OC.nkg: Number of global parameters\nOC.kg_llim: Lower bound on global parameters\nOC.kg_ulim: Upper bound on global parameters","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Note that these have to be passed to the function through the auxillary parameters tupple p","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"OC.kg_llim = []\nOC.kg_ulim = []","category":"page"},{"location":"rocket.html#Setting-up-the-event-function","page":"Rocket Control","title":"Setting up the event function","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"*OC.npsi: Number of constraints in event function *OC.psi_llim: Lower bound on constraint function *OC.psi_ulim: Upper bound on constraint function *OC.psi : Function which contains the event constraints","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"OC.npsi = 1\nOC.psi_llim = [0.0]\nOC.psi_ulim = [0.0]","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Not the format of he event function psi. It takes the OCP object as input. The OCP object has all the phases stored in it in the field OC.ph. Each phase has state variables which can be accessed by ph.x and input variable which can be accessed by ph.u. In this problem we want that u must have a zero value at end of the phase.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"function psi(ocp::DOC.OCP)\n    (;ph) = ocp\n\n    v1 = ph[1].u[:, end]\n\n    return [v1;]\nend\nOC.psi = psi","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Callback function can be used to log variables Set it to return nothing if you do not want to log variables in mesh iterations","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"ph.callback_nt = (tau_hist = Vector{Float64}[],err_hist = Vector{Float64}[])\nfunction callback_fun(ph::DOC.PH)\n    push!(ph.callback_nt.tau_hist, deepcopy(ph.tau))\n    push!(ph.callback_nt.err_hist, deepcopy(ph.error))\nend\nph.callback_fun = callback_fun","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Call function to setup the JuMP model for solving optimal control problem","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"DOC.setup_mpocp(OC)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Solve for the control and state","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"DOC.solve_mpocp(OC)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"DOC.solve(OC)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"solution_summary(OC.model)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Display results","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"println(\"Objective Value: \", objective_value(OC.model))\n\n# using GLMakie\n# f = Figure()\n# ax1 = Axis(f[1,1])\n# lines!(ax1, value.(ph.t), value.(ph.x[1,:]))\n# ax2 = Axis(f[2,1])\n# lines!(ax2, value.(ph.t), value.(ph.x[2,:]))\n# ax3 = Axis(f[1, 2])\n# lines!(ax3, value.(ph.t), value.(ph.x[3,:]))\n# ax4 = Axis(f[2, 2])\n# lines!(ax4,value.(ph.t), value.(ph.u[1,:]))\n# display(f)\n\n# fth = Figure()\n# axth = Axis(fth[1,1])\n# n = length(ph.callback_nt.tau_hist)\n# for i = 1:n\n#     ni = length(ph.callback_nt.tau_hist[i])\n#     tau = ph.callback_nt.tau_hist[i]\n#     scatter!(axth,tau,i*ones(ni))\n# end\n\n# feh = Figure()\n# axeh = Axis(feh[1,1])\n# n = length(ph.callback_nt.err_hist)\n# for i = 3:n\n#     ni = length(ph.callback_nt.err_hist[i])\n#     err = ph.callback_nt.err_hist[i]\n#     tau = ph.callback_nt.tau_hist[i]\n#     lines!(axeh,tau[1:end-1],err)\n# end","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"This page was generated using Literate.jl.","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"include(\"../src/DirectOptimalControl.jl\")\nimport .DirectOptimalControl as NOC\n\nimport Ipopt\nusing GLMakie\nusing JuMP\n\n\nOC = NOC.OCP()\nOC.tol = 1e-4\nOC.mesh_iter_max = 5\nOC.min = false\nset_optimizer(OC.model, Ipopt.Optimizer)","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"setattribute(OC.model, \"maxiter\", 500) set_attribute(OC.model, \"tol\", 1e-4)","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"h0 = 1                      # Initial height\nv0 = 0                      # Initial velocity\nm0 = 1.0                    # Initial mass\nmT = 0.6                    # Final mass\ng0 = 1                      # Gravity at the surface\nhc = 500                    # Used for drag\nc = 0.5 * sqrt(g0 * h0)    # Thrust-to-fuel mass\nDc = 0.5 * 620 * m0 / g0  # Drag scaling\nutmax = 3.5 * g0 * m0    # Maximum thrust\nTmax = 0.2                  # Number of seconds\n\nx0 = [h0, v0, m0]\n\np = (g0 = g0, hc = hc, c = c, Dc = Dc, xh0 = h0, utmax = utmax, x0 = x0)\n\nns = 3\nnu = 1\nn = 1000","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"System dynamics","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"D(xh, xv, p) = p.Dc*(xv^2)*exp(-p.hc*(xh - p.xh0)/p.xh0)\ng(xh, p) = p.g0*(p.xh0/xh)^2\nfunction dyn(x, u, t, p)\n    h = x[1]\n    phi = x[2]\n    h1 =\n    phi2 =\n    theta3 =\n    v4 =\n    gamma5 =\n    psi6 =\n\n    return [h1, phi2, theta3, v4, gamma4, psi6]\nend","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"Objective Function Running cost","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"function L(x, u, t, p)\n    return 0.0\nend\n\nfunction phi(xf, uf, tf, p)\n    return xf[1]\nend","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"Phase 1","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"ph1 = NOC.PH(OC)\nph1.L = L\nph1.phi = phi\nph1.dyn = dyn\n\nph1.n = n\nph1.tau = range(start = 0, stop = 1, length = ph1.n)\nph1.ns = ns\nph1.nu = nu\nph1.p = p\n\nph1.limits.ll.u = [0.0]\nph1.limits.ul.u = [p.utmax]\nph1.limits.ll.x = [0.3, 0.0, mT]\nph1.limits.ul.x = [2.0, 2.0, 2.0]\nph1.limits.ll.xf = [0.3, 0, mT]\nph1.limits.ul.xf = [2.0, 2.0, 2.0]\nph1.limits.ll.xi = p.x0\nph1.limits.ul.xi = p.x0\nph1.limits.ll.ti = 0.0\nph1.limits.ul.ti = 0.0\nph1.limits.ll.tf = 0.2\nph1.limits.ul.tf = 0.2\nph1.limits.ll.dt = 0.0\nph1.limits.ul.dt = 0.2","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"Add the boundary constraints","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"function psi(ocp::NOC.OCP)\n    (;ph) = ocp","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"Phase 1","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"    v1 = ph[1].ti - 0.0\n    v2 = ph[1].u[:, end]\n    v3 = ph[1].xi - ph[1].p.x0\n    v4 = ph[1].tf - 0.2\n\n\n    return [v2;]","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"return nothing","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"end\n\nOC.psi = psi","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"c = NOC.add_phase(ph1, OC)","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"NOC.solve(OC)","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"Solve for the control and state","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"solution_summary(OC.model)","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"Display results","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"println(\"Min time: \", objective_value(OC.model))","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"x, u, dt, oc = NOC.solve(OC)","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"f1, ax1, l1 = lines(value.(ph1.t), value.(ph1.x[1,:]))\nf2, ax2, l2 = lines(value.(ph1.t), value.(ph1.x[2,:]))\nf3, ax3, l3 = lines(value.(ph1.t), value.(ph1.x[3,:]))\nf4, ax4, l4 = lines(value.(ph1.t), value.(ph1.u[1,:]))\ndisplay(f1)\ndisplay(f2)\ndisplay(f3)","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"","category":"page"},{"location":"spacecraft.html","page":"Space craft","title":"Space craft","text":"This page was generated using Literate.jl.","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"# include(\"../src/DirectOptimalControl.jl\")\n# import .DirectOptimalControl as DOC\n\nimport DirectOptimalControl as DOC\nimport Ipopt\nusing JuMP","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"Common parameters","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"vm = 1.0   # Max forward speed\num = 1.0   # Max turning speed\nns = 3     # Number of states\nnu = 2     # Number of inputs\nn = 20    # Time steps","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"System dynamics","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"function dyn(x, u, t, p)\n    return [u[2] * cos(x[3]), u[2] * sin(x[3]), u[1]]\nend","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"Objective Function Running cost","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"function L(x, u, t, p)\n    return 1.0\nend\n\nfunction phi(xf, uf, tf, p)\n    return 0.0\nend\n\nfunction integralfun(x, u, t, p)\n    return nothing\nend\n\nfunction pathfun(x, u, t, p)\n    return nothing\nend\n\nOC = DOC.OCP()\nOC.tol = 1e-5\nOC.mesh_iter_max = 15\nOC.objective_sense = \"Min\"\nset_optimizer(OC.model, Ipopt.Optimizer)\nset_attribute(OC.model, \"linear_solver\", \"mumps\")\nset_attribute(OC.model, \"print_level\", 0)\n# set_attribute(OC.model, \"max_iter\", 500)\nset_attribute(OC.model, \"tol\", 1e-6)","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"Phase 1","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"ph1 = DOC.PH(OC)\nph1.L = L\nph1.phi = phi\nph1.dyn = dyn\nph1.integralfun = integralfun\nph1.collocation_method = \"hermite-simpson\"\nph1.scale_flag = true\n\nph1.n = n\nph1.ns = ns\nph1.nu = nu\nph1.nq = 0\nph1.nk = 0","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"Auxillary parameters","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"ph1.p = (k1 = 1.0, k2 = 2.0)\n\nph1.limits.ll.u = [-1.0, 0.75*vm]\nph1.limits.ul.u = [1.0, vm]\nph1.limits.ll.x = [-10.0, -10.0, -10.0]\nph1.limits.ul.x = [10.0, 10.0, 10.0]\nph1.limits.ll.xf = [5.0, 5.0, π / 2 + π / 4]\nph1.limits.ul.xf = [5.0, 5.0, π / 2 + π / 4]\nph1.limits.ll.xi = [0, 0, -π / 2]\nph1.limits.ul.xi = [0, 0, -π / 2]\nph1.limits.ll.ti = 0.0\nph1.limits.ul.ti = 0.0\nph1.limits.ll.tf = 5.0\nph1.limits.ul.tf = 20.0\nph1.limits.ll.dt = 5.0\nph1.limits.ul.dt = 20.0\nph1.limits.ll.k = []\nph1.limits.ul.k = []","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"ph.setinitialvalues can take two values: \"Auto\" and \"User\" Set initial values","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"ph1.set_initial_vals = \"Auto\"","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"Phase 2","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"ph2 = DOC.PH(OC)\nph2.L = L\nph2.phi = phi\nph2.dyn = dyn\nph2.integralfun = integralfun\nph2.collocation_method = \"hermite-simpson\"\nph2.scale_flag = true\n\nph2.n = n\nph2.ns = ns\nph2.nu = nu\nph2.nq = 0\nph2.nk = 0\n\nph2.p = (k1 = 1.0, k2 = 2.0)\n\nph2.limits.ll.u = [-1.0, 0.75*vm]\nph2.limits.ul.u = [1.0, vm]\nph2.limits.ll.x = [-10.0, -10.0, -10.0]\nph2.limits.ul.x = [10.0, 10.0, 10.0]\nph2.limits.ll.xf =  [-5, 5, 0.0]\nph2.limits.ul.xf =  [-5, 5, 0.0]\nph2.limits.ll.xi = ph1.limits.ll.xf\nph2.limits.ul.xi = ph1.limits.ul.xf\nph2.limits.ll.ti = ph1.limits.ll.tf\nph2.limits.ul.ti = ph1.limits.ul.tf\nph2.limits.ll.dt = 5.0\nph2.limits.ul.dt = 20.0\nph2.limits.ll.tf = ph2.limits.ll.ti + ph2.limits.ll.dt\nph2.limits.ul.tf = ph2.limits.ul.ti + ph2.limits.ul.dt","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"Phase 3","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"ph3 = DOC.PH(OC)\nph3.L = L\nph3.phi = phi\nph3.dyn = dyn\nph3.integralfun = integralfun\n\nph3.n = n\nph3.tau = range(start = 0, stop = 1, length = ph3.n)\nph3.ns = ns\nph3.nu = nu\nph3.p = (k1 = 1.0, k2 = 2.0)\n\nph3.limits.ll.u = [-1.0, 0.75*vm]\nph3.limits.ul.u = [1.0, vm]\nph3.limits.ll.x = [-10.0, -10.0, -10.0]\nph3.limits.ul.x = [10.0, 10.0, 10.0]\nph3.limits.ll.xf =  [-5, -5, 0.0]\nph3.limits.ul.xf =  [-5, -5, 0.0]\nph3.limits.ll.xi = ph2.limits.ll.xf\nph3.limits.ul.xi = ph2.limits.ul.xf\nph3.limits.ll.ti = ph2.limits.ll.tf\nph3.limits.ul.ti = ph2.limits.ul.tf\nph3.limits.ll.dt = 7.0\nph3.limits.ul.dt = 20.0\nph3.limits.ll.tf = ph3.limits.ll.ti + ph3.limits.ll.dt\nph3.limits.ul.tf = ph3.limits.ul.ti + ph3.limits.ul.dt\nph3.collocation_method = \"hermite-simpson\"\nph3.scale_flag = true","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"Phase 4","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"ph4 = DOC.PH(OC)\nph4.L = L\nph4.phi = phi\nph4.dyn = dyn\nph4.integralfun = integralfun\n\nph4.n = n\nph4.tau = range(start = 0, stop = 1, length = ph4.n)\nph4.ns = ns\nph4.nu = nu\nph4.p = (k1 = 1.0, k2 = 2.0)\n\nph4.limits.ll.u = [-1.0, 0.75*vm]\nph4.limits.ul.u = [1.0, vm]\nph4.limits.ll.x = [-10.0, -10.0, -10.0]\nph4.limits.ul.x = [10.0, 10.0, 10.0]\nph4.limits.ll.xf =  ph1.limits.ll.xi\nph4.limits.ul.xf =  ph1.limits.ul.xi\nph4.limits.ll.xi = ph3.limits.ll.xf\nph4.limits.ul.xi = ph3.limits.ul.xf\nph4.limits.ll.ti = ph3.limits.ll.tf\nph4.limits.ul.ti = ph3.limits.ul.tf\nph4.limits.ll.dt = 7.0\nph4.limits.ul.dt = 20.0\nph4.limits.ll.tf = ph4.limits.ll.ti + ph4.limits.ll.dt\nph4.limits.ul.tf = ph4.limits.ul.ti + ph4.limits.ul.dt\nph4.collocation_method = \"hermite-simpson\"\nph4.scale_flag = true","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"Add the boundary constraints","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"function psi(ocp::DOC.OCP)\n    (;ph) = ocp\n\n    v4 = ph[2].ti - ph[1].tf\n    v7 = ph[3].ti - ph[2].tf\n    v10 = ph[4].ti - ph[3].tf\n\n    return [v4, v7, v10]\nend\n\nOC.psi = psi\nOC.npsi = 3\nOC.set_obj_lim = true\nOC.obj_llim = 0.0\nOC.obj_ulim = 43\nOC.psi_llim = [0.0, 0.0, 0.0]\nOC.psi_ulim = [0.0, 0.0, 0.0]\n\nDOC.setup_mpocp(OC)\nDOC.solve_mpocp(OC)\n# DOC.solve(OC)","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"Solve for the control and state","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"solution_summary(OC.model)","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"Display results","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"println(\"Min time: \", objective_value(OC.model))\n\n\n# using GLMakie\n# f1, ax1, l1 = lines(value.(ph1.x[1, :]), value.(ph1.x[2, :]))\n# l2 = lines!(ax1, value.(ph2.x[1, :]), value.(ph2.x[2, :]))\n# l3 = lines!(ax1, value.(ph3.x[1, :]), value.(ph3.x[2, :]))\n# l4 = lines!(ax1, value.(ph4.x[1, :]), value.(ph4.x[2, :]))\n# ax1.autolimitaspect = 1.0\n# # f1\n\n# f2, ax2, l21 = lines(value.(ph1.t), value.(ph1.u[1, :]))\n# l22 = lines!(ax2, value.(ph2.t), value.(ph2.u[1, :]))\n# l23 = lines!(ax2, value.(ph3.t), value.(ph3.u[1, :]))\n# l24 = lines!(ax2, value.(ph4.t), value.(ph4.u[1, :]))\n# f2\n\n# f3, ax3, l31 = lines(value.(ph1.t), value.(ph1.u[2, :]))\n# l32 = lines!(ax3, value.(ph2.t), value.(ph2.u[2, :]))\n# l33 = lines!(ax3, value.(ph3.t), value.(ph3.u[2, :]))\n# l34 = lines!(ax3, value.(ph4.t), value.(ph4.u[2, :]))\n# f3\n\n\n# f4, ax4, l4 = lines(value.(ph1.xinit[1, :]), value.(ph1.xinit[2, :]))\n# l2 = lines!(ax4, value.(ph2.xinit[1, :]), value.(ph2.xinit[2, :]))\n# l3 = lines!(ax4, value.(ph3.xinit[1, :]), value.(ph3.xinit[2, :]))\n# l4 = lines!(ax4, value.(ph4.xinit[1, :]), value.(ph4.xinit[2, :]))\n# ax4.autolimitaspect = 1.0\n# f4","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"","category":"page"},{"location":"dubins_multiple_phase.html","page":"Dubins multiple phase","title":"Dubins multiple phase","text":"This page was generated using Literate.jl.","category":"page"},{"location":"README.html#A-package-to-solve-multiple-phase-optimal-control-problems","page":"Introduction","title":"A package to solve multiple-phase optimal control problems","text":"","category":"section"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"An p-phase optimal control problem can be stated in the following general form. Determine the state, bf x^(p)(t) in mathbbR^n_z^(p) control bf u^(p)(t) in mathbbR^n_u^(p), initial time t_0^(p)inmathbbR, final time t_f^(p)inmathbbR, integrals, bf q^(p)inmathbbR^n_q^(p), local parameters bf k_p in mathbbR^n_k^(p)  in each phase pin1P, and the static parameters, bf k_ginmathbbR^n_kg, that minimize the cost functional ","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"J=sum_p=1^nJ_p","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"where,","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"J_p=intop_t_i^p^t_f^pL^p(bf x^(p)(t)bf u^(p)(t)t^(p)bf kbf ap) dt^p+phi(x^(p)(t_f^p)u^(p)(t_f^p)t_f^(p)bf kbf ap)","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"Note: bf ap contains all the auxillary parameters used to define various functions,  and bf k =bf k_p bf k_g is a stacked vector of phase and global parameters which can be optimized. ","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"The cost funtional J must be minimized subject to the following constraints in each phase p:","category":"page"},{"location":"README.html#Path-constraints:","page":"Introduction","title":"Path constraints:","text":"","category":"section"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"Path constraints are the constraints which the states and controls must obey at each instant t^(p) .","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"bf pf_l^(p)leqbf pathfun^(p)(bf x^p(t)bf u^p(t)t^(p)bf kbf ap)inmathbbR^n_pf^kleqbf pf_u^(p) forall t^(p)int_i^(p)t_f^(p)","category":"page"},{"location":"README.html#Integral-constraints:","page":"Introduction","title":"Integral constraints:","text":"","category":"section"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"Define: ","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"bf IF^(p)=intop_t_i^p^t_f^pbf integralfun^(p)(bf x^(p)(t)bf u^(p)(t)t^(p)bf kbf ap) dt^(p)","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"bf if_l^(p)leqbf pathfun(bf x^p(t)bf u^p(t)t^(p)bf kbf ap)inmathbbR^n_pf^kleqbf if_u^(p)","category":"page"},{"location":"README.html#Event-constraints:","page":"Introduction","title":"Event constraints:","text":"","category":"section"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"Events in time are what cause a change of phase. Event constraints represent linkages between initial times, states, inputs and final times, states, inputs between phases.","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"bf psi_u^(p)leqbf psi(t_i^(1)t_f^(1)bf x_f^(1)bf u_f^(1)t_i^(2)t_f^(2)bf x_f^(2)bf u_f^(2)ldots t_i^(P)t_f^(P)bf x_f^(P)bf u_f^(P))inmathbbR^n_psi^(p)leqbf psi_u^(p)","category":"page"},{"location":"README.html#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"Multiple phases\nScaling\nMesh recomputation\nFlexibility in formulating problems","category":"page"},{"location":"README.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"add https://github.com/A-C1/DirectOptimalControl.jl","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"# include(\"../src/DirectOptimalControl.jl\")\n# import .DirectOptimalControl as DOC\n\nimport DirectOptimalControl as DOC\nimport Ipopt\nusing JuMP\n\nOC = DOC.OCP()\nOC.tol = 1e-5\nOC.mesh_iter_max = 10\nOC.objective_sense = \"Min\"\nset_optimizer(OC.model, Ipopt.Optimizer)\nset_attribute(OC.model, \"print_level\", 0)\nset_attribute(OC.model, \"max_iter\", 500)\nset_attribute(OC.model, \"tol\", 1e-6)\n\n\nx0 = [2, 1, 2, 1]\nxf = [2, 3, 1, -2]\nt0 = 0\ntf = 20\n\np = (x0 = x0, xf = xf, t0 = t0, tf = tf)\n\nns = 4\nnu = 2\nn = 500\nnp = 1","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"System dynamics","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"pf(t, a, b) = exp(-b*(t-a)^2)\nfunction dyn(x, u, t, p)\n    x1 = -10x[1] + u[1] + u[2]\n    x2 = -2x[2] + u[1] + 2u[2]\n    x3 = -3x[3] + 5x[4] + u[1] - u[2]\n    x4 = 5x[3] - 3x[4] + u[1] + 3u[2]\n\n    return [x1, x2, x3, x4]\nend","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"Objective Function Running cost","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"function L(x, u, t, p)\n    return 100*(x[1]^2 + x[2]^2 + x[3]^2 + x[4]^2) + 0.01(u[1]^2 + u[2]^2)\nend\n\nfunction phi(xf, uf, tf, p)\n    return 0.0\nend\n\nfunction integralfun(x, u, t, p)\n    return nothing\nend","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"Path function","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"function pathfun(x, u, t, p)\n    v1 = x[1]^2 + x[2]^2 + x[3]^2 + x[4]^2 - (3*pf(t, 3.0, 12.0) + 3*pf(t, 6.0, 10.0) + 3*pf(t, 10.0, 6.0) + 8*pf(t, 15.0, 4.0) + 0.01 )\n    return [v1]\nend","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"Phase 1","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"ph = DOC.PH(OC)\nph.L = L\nph.phi = phi\nph.dyn = dyn\nph.integralfun = integralfun\nph.pathfun = pathfun\nph.collocation_method = \"hermite-simpson\"\nph.scale_flag = true\n\nph.n = n\nph.ns = ns\nph.nu = nu\nph.np = np\nph.nq = 0\nph.p = p\n\nph.limits.ll.u = -1e3*[1.0, 1.0]\nph.limits.ul.u = 1e3*[1.0, 1.0]\nph.limits.ll.x = -1e1*[1.0, 1.0, 1.0, 1.0]\nph.limits.ul.x = 1e1*[1.0, 1.0, 1.0, 1.0]\nph.limits.ll.xf = xf\nph.limits.ul.xf = xf\nph.limits.ll.xi = x0\nph.limits.ul.xi = x0\nph.limits.ll.ti = t0\nph.limits.ul.ti = t0\nph.limits.ll.tf = tf\nph.limits.ul.tf = tf\nph.limits.ll.dt = tf-t0\nph.limits.ul.dt = tf-t0\nph.limits.ll.path = [0]\nph.limits.ul.path = [10000]\n\nph.set_initial_vals = \"Auto\"","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"Add the boundary constraints","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"function psi(ocp::DOC.OCP)\n    (;ph) = ocp\n\n    return nothing\nend\n\nOC.psi = psi\nOC.psi_llim = []\nOC.psi_ulim = []\nOC.set_obj_lim = false\nOC.obj_llim = 1e6\nOC.obj_ulim = -1e6","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"Callback function can be used to log variables Set it to return nothing if you do not want to log variables in mesh iterations","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"ph.callback_nt = (tau_hist = Vector{Float64}[],err_hist = Vector{Float64}[])\nfunction callback_fun(ph::DOC.PH)\n    push!(ph.callback_nt.tau_hist, deepcopy(ph.tau))\n    push!(ph.callback_nt.err_hist, deepcopy(ph.error))\nend\nph.callback_fun = callback_fun\n\nDOC.setup_mpocp(OC)\nDOC.solve_mpocp(OC)\n# DOC.solve(OC)\n\nsolution_summary(OC.model)","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"Display results","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"println(\"Objective Value: \", objective_value(OC.model))\n\n\n# using GLMakie\n# f1, ax1, l1 = lines(value.(ph.t), value.(ph.x[1,:]))\n# f2, ax2, l2 = lines(value.(ph.t), value.(ph.x[2,:]))\n# f3, ax3, l3 = lines(value.(ph.t), value.(ph.x[3,:]))\n# f4, ax4, l4 = lines(value.(ph.t), value.(ph.x[4,:]))\n# fu1 = lines(value.(ph.t), value.(ph.u[1,:]))\n# fu2 = lines(value.(ph.t), value.(ph.u[2,:]))","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"","category":"page"},{"location":"alprider.html","page":"Alp Rider","title":"Alp Rider","text":"This page was generated using Literate.jl.","category":"page"},{"location":"index.html","page":"-","title":"-","text":"DOC.trapezoidal(ph::DOC.PH, model::DOC.Model)","category":"page"},{"location":"index.html#DirectOptimalControl.trapezoidal-Tuple{DirectOptimalControl.PH1, JuMP.Model}","page":"-","title":"DirectOptimalControl.trapezoidal","text":"trapezoidal(ph, model)\n\nAdds trapezoidal collocation to model.\n\n\n\n\n\n","category":"method"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"# include(\"../src/DirectOptimalControl.jl\")\n# import .DirectOptimalControl as DOC\n\nimport DirectOptimalControl as DOC\n\nimport Ipopt\nusing JuMP\n\n\nOC = DOC.OCP()\nOC.tol = 1e-12\nOC.mesh_iter_max = 5\nOC.objective_sense = \"Min\"\nset_optimizer(OC.model, Ipopt.Optimizer)\nset_attribute(OC.model, \"print_level\", 0)\n# set_attribute(OC.model, \"max_iter\", 500)\n# set_attribute(OC.model, \"tol\", 1e-4)","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"Parameters: Data Required by Problem","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"zeta = 0.084\nb = 5.85\nd = 0.00873\nG = 0.15\nmu = 0.02\na = 75\nA = 15","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"Boundary Conditions","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"pMax = ((b-mu)/d)^(3/2)\npMin = 0.1\nqMax = pMax\nqMin = pMin\nyMax = A\nyMin = 0\nuMax = a\nuMin = 0\nt0Max = 0\nt0Min = 0\ntfMax = 5\ntfMin = 0.1\np0 = pMax/2\nq0 = qMax/4\ny0 = 0\n\np = (zeta = zeta, b = b, d = d, G = G, mu = mu)\n\nns = 2\nnu = 1\nn = 20\nnq = 1","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"System dynamics","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"pf(t, a, b) = exp(-b*(t-a)^2)\nfunction dyn(x, u, t, p)\n    x1 = -p.zeta*x[1]*log(x[1]/x[2])\n    x2 = x[2]*(p.b - p.mu -p.d*(x[1])^(2/3) - p.G*u[1] )\n\n    return [x1, x2]\nend","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"Objective Function Running cost","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"function L(x, u, t, p)\n    return 0.0\nend\n\nfunction phi(xf, uf, tf, p)\n    return xf[1]\nend","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"Integration function","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"function integralfun(x, u, t, p)\n    return [u[1]]\nend","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"Phase 1","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"ph = DOC.PH(OC)\nph.L = L\nph.phi = phi\nph.dyn = dyn\nph.integralfun = integralfun\nph.collocation_method = \"trapezoidal\"\n\nph.n = n\nph.ns = ns\nph.nu = nu\nph.nq = nq\nph.np = 0\nph.p = p\n\nph.limits.ll.u = [uMin]\nph.limits.ul.u = [uMax]\nph.limits.ll.x = [pMin, qMin]\nph.limits.ul.x = [pMax, qMax]\nph.limits.ll.xf = [pMin, qMin]\nph.limits.ul.xf = [pMax, qMax]\nph.limits.ll.xi = [p0, q0]\nph.limits.ul.xi = [p0, q0]\nph.limits.ll.ti = t0Min\nph.limits.ul.ti = t0Max\nph.limits.ll.tf = tfMin\nph.limits.ul.tf = tfMax\nph.limits.ll.dt = tfMin-t0Min\nph.limits.ul.dt = tfMax-t0Max\nph.limits.ll.integral = [-1000.0]\nph.limits.ul.integral = [A]","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"Add the boundary constraints","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"function psi(ocp::DOC.OCP)\n    (;ph) = ocp","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"return [v2;]","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"    return nothing\nend\n\nOC.psi = psi\nOC.npsi = 0\n\nDOC.setup_mpocp(OC)\nDOC.solve_mpocp(OC)\nsolution_summary(OC.model)","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"Display results","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"println(\"Min time: \", objective_value(OC.model))\n\n# using GLMakie\n# fx1, ax1, l1 = scatter(value.(ph.t), value.(ph.x[1,:]))\n# fx2, ax2, l2 = scatter(value.(ph.t), value.(ph.x[2,:]))\n# fu1 = scatter(value.(ph.t), value.(ph.u[1,:]))\n# fx1","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"","category":"page"},{"location":"tumor_antiogenesis.html","page":"Tumor antiogenesis","title":"Tumor antiogenesis","text":"This page was generated using Literate.jl.","category":"page"}]
}

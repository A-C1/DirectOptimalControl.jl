<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rocket Control · Direct Optimal Control</title><meta name="title" content="Rocket Control · Direct Optimal Control"/><meta property="og:title" content="Rocket Control · Direct Optimal Control"/><meta property="twitter:title" content="Rocket Control · Direct Optimal Control"/><meta name="description" content="Documentation for Direct Optimal Control."/><meta property="og:description" content="Documentation for Direct Optimal Control."/><meta property="twitter:description" content="Documentation for Direct Optimal Control."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="README.html">Direct Optimal Control</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="README.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="rocket.html">Rocket Control</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Set-solver-configuration"><span>Set solver configuration</span></a></li><li class="toplevel"><a class="tocitem" href="#Define-the-models-and-cost-functions"><span>Define the models and cost functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Assignement-to-Phase-object"><span>Assignement to Phase object</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="rocket.html">Rocket Control</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="rocket.html">Rocket Control</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/A-C1/DirectOptimalControl.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/A-C1/DirectOptimalControl.jl/blob/master/docs/src/rocket.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Our goal is to maximize the final altitude of a vertically launched rocket.</p><p>We can control the thrust of the rocket, and must take account of the rocket mass, fuel consumption rate, gravity, and aerodynamic drag.</p><p>Let us consider the basic description of the model (for the full description, including parameters for the rocket, see <a href="https://www.mcs.anl.gov/~more/cops/cops3.pdf">COPS3</a>).</p><p>There are three state variables in our model:</p><ul><li>Velocity: <span>$x_v(t)$</span></li><li>Altitude: <span>$x_h(t)$</span></li><li>Mass of rocket and remaining fuel, <span>$x_m(t)$</span></li></ul><p>and a single control variable:</p><ul><li>Thrust: <span>$u_t(t)$</span>.</li></ul><p>There are three equations that control the dynamics of the rocket:</p><ul><li>Rate of ascent: <span>$\frac{d x_h}{dt} = x_v$</span></li><li>Acceleration: <span>$\frac{d x_v}{dt} = \frac{u_t - D(x_h, x_v)}{x_m} - g(x_h)$</span></li><li>Rate of mass loss: <span>$\frac{d x_m}{dt} = -\frac{u_t}{c}$</span></li></ul><p>where drag <span>$D(x_h, x_v)$</span> is a function of altitude and velocity, gravity <span>$g(x_h)$</span> is a function of altitude, and <span>$c$</span> is a constant.</p><p>These forces are defined as:</p><p class="math-container">\[D(x_h, x_v) = D_c \cdot x_v^2 \cdot e^{-h_c \left( \frac{x_h-x_h(0)}{x_h(0)} \right)}\]</p><p>and <span>$g(x_h) = g_0 \cdot \left( \frac{x_h(0)}{x_h} \right)^2$</span></p><p>We use a discretized model of time, with a fixed number of time steps, <span>$T$</span>.</p><p>Our goal is thus to maximize <span>$x_h(T)$</span>.</p><pre><code class="language-julia hljs">import DirectOptimalControl as DOC
using JuMP
import Ipopt
using GLMakie</code></pre><h2 id="Set-solver-configuration"><a class="docs-heading-anchor" href="#Set-solver-configuration">Set solver configuration</a><a id="Set-solver-configuration-1"></a><a class="docs-heading-anchor-permalink" href="#Set-solver-configuration" title="Permalink"></a></h2><p>Let us set first create an optimal control problem. The structure which stores all the data related to the optimal control problem is called OCP (Optimal control problem).</p><pre><code class="language-julia hljs">OC = DOC.OCP()</code></pre><p>Now we will set various parameters for the solver</p><ul><li>OC.tol : Sets up tolerence for the solver. In the intial run it is advisable to keep the tolerance height</li><li>OC.mesh<em>iter</em>max : This is the maximum number of iterations that the solver takes</li><li>OC.objective_sense: You can set two options here &quot;Max&quot; or &quot;Min&quot; depending on weather the objective is to be minimized or maximized</li></ul><pre><code class="language-julia hljs">OC.tol = 1e-7
OC.mesh_iter_max = 10
OC.objective_sense = &quot;Max&quot;</code></pre><p>Now it is time to select an optimizer. Let us select the Ipopt optimizer. The OC struct contains an JuMP model in its field OC.model. We can assign any non-linear optimizer that JuMP supports. For this reason we needed to import JuMP. It is advisable to initially keep the solver tolerance higher so that the optimizer converges.</p><pre><code class="language-julia hljs">set_optimizer(OC.model, Ipopt.Optimizer)
set_attribute(OC.model, &quot;print_level&quot;, 0)</code></pre><p>set<em>attribute(OC.model, &quot;max</em>iter&quot;, 500) set_attribute(OC.model, &quot;tol&quot;, 1e-4)</p><h1 id="Define-the-models-and-cost-functions"><a class="docs-heading-anchor" href="#Define-the-models-and-cost-functions">Define the models and cost functions</a><a id="Define-the-models-and-cost-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-models-and-cost-functions" title="Permalink"></a></h1><p>Now let us define the objectives and functions which make up the model</p><pre><code class="language-julia hljs">h0 = 1                      # Initial height
v0 = 0                      # Initial velocity
m0 = 1.0                    # Initial mass
mT = 0.6                    # Final mass
g0 = 1                      # Gravity at the surface
hc = 500                    # Used for drag
c = 0.5 * sqrt(g0 * h0)     # Thrust-to-fuel mass
Dc = 0.5 * 620 * m0 / g0    # Drag scaling
utmax = 3.5 * g0 * m0       # Maximum thrust
Tmax = 0.2                  # Number of seconds

x0 = [h0, v0, m0]

p = (g0 = g0, hc = hc, c = c, Dc = Dc, xh0 = h0, utmax = utmax, x0 = x0)

ns = 3
nu = 1
n = 1000</code></pre><h3 id="System-dynamics"><a class="docs-heading-anchor" href="#System-dynamics">System dynamics</a><a id="System-dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#System-dynamics" title="Permalink"></a></h3><p>Note that the dyn function which defines the dynamics must be in a particular format. It must five inputs: x : The state of system at time t u : The input of system at time t t : The time t p : p is a named tuple of auzillary parameters required to define the fucntion k : k is a named tuple containing kg and kp</p><pre><code class="language-julia hljs">D(xh, xv, p) = p.Dc*(xv^2)*exp(-p.hc*(xh - p.xh0)/p.xh0)
g(xh, p) = p.g0*(p.xh0/xh)^2
function dyn(x, u, t, p)
    xhn = x[2]
    xvn = (u[1] - D(x[1], x[2], p))/x[3] - g(x[1], p)
    xmn = -u[1]/p.c
    return [xhn, xvn, xmn]
end

function integralfun(x, u, t, p)
    return nothing
end</code></pre><h3 id="Objective-Function"><a class="docs-heading-anchor" href="#Objective-Function">Objective Function</a><a id="Objective-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Objective-Function" title="Permalink"></a></h3><p>The objective function consists of running cost and a fixed cost. The running cost function also has syntax similar to the dynamics function. For the rocket example there is no running cost involved so the running cost function returns 0.</p><pre><code class="language-julia hljs">function L(x, u, t, p)
    return 0.0
end</code></pre><p>The Final cost function involves the contribution of final state in the objective Since we want to maximize the final height the function returns <code>xf[1]</code>. This is because the first state denotes the height as per our definition of the heigth function.</p><pre><code class="language-julia hljs">function phi(xf, uf, tf, p)
    return xf[1]
end</code></pre><h3 id="Integral-functions"><a class="docs-heading-anchor" href="#Integral-functions">Integral functions</a><a id="Integral-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Integral-functions" title="Permalink"></a></h3><p>Some of the problems can have integral constraints associated with them in each phase Since this problem does not have an integral constraint the <code>integralfun</code> will return <code>nothing</code>.</p><pre><code class="language-julia hljs">function integralfun(x, u, t, p)
    return nothing
end</code></pre><h3 id="Path-functions"><a class="docs-heading-anchor" href="#Path-functions">Path functions</a><a id="Path-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Path-functions" title="Permalink"></a></h3><p>Some of the problems can have path constraints associated with them in each phase Since this problem does not have an path constraint the <code>pathfun</code> will return <code>nothing</code>.</p><pre><code class="language-julia hljs">function pathfun(x, u, t, p)
    return nothing
end

function integralfun(x, u, t, p)
    return nothing
end</code></pre><h1 id="Assignement-to-Phase-object"><a class="docs-heading-anchor" href="#Assignement-to-Phase-object">Assignement to Phase object</a><a id="Assignement-to-Phase-object-1"></a><a class="docs-heading-anchor-permalink" href="#Assignement-to-Phase-object" title="Permalink"></a></h1><p>Each OCP must contain atleast one phase. The synatax for adding the phase to an OCP is given by</p><pre><code class="language-julia hljs">ph = DOC.PH(OC)</code></pre><p>Now let us assign the various functions defined above to the phase <code>ph</code> that we have just created</p><pre><code class="language-julia hljs">ph.L = L      # Adding the running cost
ph.phi = phi  # Adding the final time cost
ph.dyn = dyn  # Add the dynamics
ph.integralfun = integralfun # Add the integral constraint function
ph.pathfun = pathfun # Add the integral constraint function
ph.n = n    # Number of points in initial mesh
ph.ns = ns  # State dimension
ph.nu = nu  # Input dimension
ph.nq = 0   # Dimension of the quadrature (integral) constraint
ph.nk = 0   # Dimension of the optimizable phase paramters
ph.np = 0   # Dimension of the path constraints
ph.p = p    # Auxillary parametrs named tuple</code></pre><p>Let us select some of the options for the phase</p><ul><li>Collocation method: Two options [&quot;hermite-simpson&quot;, &quot;trapezoidal&quot;]. Default is &quot;hermite-simpson&quot;</li><li>Scale: Two options <code>true</code> or <code>false</code></li></ul><pre><code class="language-julia hljs">ph.collocation_method = &quot;hermite-simpson&quot;
ph.scale_flag = true</code></pre><p>Now let us set the upper bounds and lower bounds on all the variables pathconstaints and integral constraints</p><pre><code class="language-julia hljs">ph.limits.ll.u = [0.0]      # Lower bounds on input. Vector of dimension `nu`
ph.limits.ul.u = [p.utmax]  # Upper bounds on input. Vector of dimesion `ns`
ph.limits.ll.x = [0.0, 0.0, 0.0] # Lower bounds on input. Vector of dimension `nu`
ph.limits.ul.x = [2.0, 2.0, 2.0] # Upper bounds on input. Vector of dimesion `ns`
ph.limits.ll.xf = [0.3, 0, mT]      # Lower bounds on input. Vector of dimension `nu`
ph.limits.ul.xf = [2.0, 2.0, 2.0]   # Upper bounds on input. Vector of dimesion `ns`
ph.limits.ll.xi = p.x0  # Lower bounds on input. Vector of dimension `nu`
ph.limits.ul.xi = p.x0  # Upper bounds on input. Vector of dimesion `ns`
ph.limits.ll.ti = 0.0   # Lower bounds on input. Vector of dimension `nu`
ph.limits.ul.ti = 0.0   # Upper bounds on input. Vector of dimesion `ns`
ph.limits.ll.tf = 0.2   # Lower bounds on input. Vector of dimension `nu`
ph.limits.ul.tf = 0.2   # Upper bounds on input. Vector of dimesion `ns`
ph.limits.ll.dt = 0.0     # Lower bounds on input. Vector of dimension `nu`
ph.limits.ul.dt = 0.2     # Upper bounds on input. Vector of dimesion `ns`</code></pre><p>ph.limits.ll.k = [] # Lower bounds on input. Vector of dimension <code>nu</code> ph.limits.ul.k = [] # Upper bounds on input. Vector of dimesion <code>ns</code> Add the boundary constraints</p><h3 id="Set-intial-values"><a class="docs-heading-anchor" href="#Set-intial-values">Set intial values</a><a id="Set-intial-values-1"></a><a class="docs-heading-anchor-permalink" href="#Set-intial-values" title="Permalink"></a></h3><p>There are two options here &quot;Auto&quot; and &quot;Manual&quot;</p><pre><code class="language-julia hljs">ph.set_initial_vals = &quot;Auto&quot;
ph.tau = range(start = 0, stop = 1, length = ph.n)
ph.xinit = ones(ph.ns, ph.n)
ph.uinit = ones(ph.nu, ph.n)
ph.tfinit = ph.limits.ll.tf
ph.tiinit = ph.limits.ll.ti</code></pre><p>ph.kinit  = (ph.limits.ll.k + ph.limits.ul.k)/2</p><p>Specify initial value OC.obj<em>llim = -2.0 OC.obj</em>ulim = 2.0</p><pre><code class="language-julia hljs">OC.psi_llim = [0.0]
OC.psi_ulim = [0.0]</code></pre><p>OC.kg<em>llim = [0.0, 0.0, 0.0] OC.kg</em>ulim = [1.0, 1.0, 1.0]</p><pre><code class="language-julia hljs">OC.nkg = 0     #  Number of global parameters  Optional parameter
OC.npsi = 1    # Optional parameter evnts
function psi(ocp::DOC.OCP)
    (;ph) = ocp

    v1 = ph[1].u[:, end]

    return [v1;]</code></pre><p>return nothing</p><pre><code class="language-julia hljs">end

OC.psi = psi</code></pre><p>Call function to setup the JuMP model for solving optimal control problem</p><pre><code class="language-julia hljs">DOC.setup_mpocp(OC)</code></pre><p>Solve for the control and state</p><pre><code class="language-julia hljs">DOC.solve_mpocp(OC)</code></pre><p>DOC.solve(OC)</p><pre><code class="language-julia hljs">solution_summary(OC.model)</code></pre><p>Display results</p><pre><code class="language-julia hljs">println(&quot;Objective Value: &quot;, objective_value(OC.model))

f = Figure()
ax1 = Axis(f[1,1])
lines!(ax1, value.(ph.t), value.(ph.x[1,:]))
ax2 = Axis(f[2,1])
lines!(ax2, value.(ph.t), value.(ph.x[2,:]))
ax3 = Axis(f[1, 2])
lines!(ax3, value.(ph.t), value.(ph.x[3,:]))
ax4 = Axis(f[2, 2])
lines!(ax4,value.(ph.t), value.(ph.u[1,:]))
display(f)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="README.html">« Introduction</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 25 December 2023 12:53">Monday 25 December 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

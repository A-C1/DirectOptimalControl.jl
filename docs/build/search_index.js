var documenterSearchIndex = {"docs":
[{"location":"rocket.html#Overview","page":"Rocket Control","title":"Overview","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Our goal is to maximize the final altitude of a vertically launched rocket.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"We can control the thrust of the rocket, and must take account of the rocket mass, fuel consumption rate, gravity, and aerodynamic drag.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Let us consider the basic description of the model (for the full description, including parameters for the rocket, see COPS3).","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"There are three state variables in our model:","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Velocity: x_v(t)\nAltitude: x_h(t)\nMass of rocket and remaining fuel, x_m(t)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"and a single control variable:","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Thrust: u_t(t).","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"There are three equations that control the dynamics of the rocket:","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Rate of ascent: fracd x_hdt = x_v\nAcceleration: fracd x_vdt = fracu_t - D(x_h x_v)x_m - g(x_h)\nRate of mass loss: fracd x_mdt = -fracu_tc","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"where drag D(x_h x_v) is a function of altitude and velocity, gravity g(x_h) is a function of altitude, and c is a constant.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"These forces are defined as:","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"D(x_h x_v) = D_c cdot x_v^2 cdot e^-h_c left( fracx_h-x_h(0)x_h(0) right)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"and g(x_h) = g_0 cdot left( fracx_h(0)x_h right)^2","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"We use a discretized model of time, with a fixed number of time steps, T.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Our goal is thus to maximize x_h(T).","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"import DirectOptimalControl as DOC\nusing JuMP\nimport Ipopt\nusing GLMakie","category":"page"},{"location":"rocket.html#Set-solver-configuration","page":"Rocket Control","title":"Set solver configuration","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Let us set first create an optimal control problem. The structure which stores all the data related to the optimal control problem is called OCP (Optimal control problem).","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"OC = DOC.OCP()","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Now we will set various parameters for the solver","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"OC.tol : Sets up tolerence for the solver. In the intial run it is advisable to keep the tolerance height\nOC.meshitermax : This is the maximum number of iterations that the solver takes\nOC.objective_sense: You can set two options here \"Max\" or \"Min\" depending on weather the objective is to be minimized or maximized","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"OC.tol = 1e-7\nOC.mesh_iter_max = 10\nOC.objective_sense = \"Max\"","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Now it is time to select an optimizer. Let us select the Ipopt optimizer. The OC struct contains an JuMP model in its field OC.model. We can assign any non-linear optimizer that JuMP supports. For this reason we needed to import JuMP. It is advisable to initially keep the solver tolerance higher so that the optimizer converges.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"set_optimizer(OC.model, Ipopt.Optimizer)\nset_attribute(OC.model, \"print_level\", 0)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"setattribute(OC.model, \"maxiter\", 500) set_attribute(OC.model, \"tol\", 1e-4)","category":"page"},{"location":"rocket.html#Define-the-models-and-cost-functions","page":"Rocket Control","title":"Define the models and cost functions","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Now let us define the objectives and functions which make up the model","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"h0 = 1                      # Initial height\nv0 = 0                      # Initial velocity\nm0 = 1.0                    # Initial mass\nmT = 0.6                    # Final mass\ng0 = 1                      # Gravity at the surface\nhc = 500                    # Used for drag\nc = 0.5 * sqrt(g0 * h0)     # Thrust-to-fuel mass\nDc = 0.5 * 620 * m0 / g0    # Drag scaling\nutmax = 3.5 * g0 * m0       # Maximum thrust\nTmax = 0.2                  # Number of seconds\n\nx0 = [h0, v0, m0]\n\np = (g0 = g0, hc = hc, c = c, Dc = Dc, xh0 = h0, utmax = utmax, x0 = x0)\n\nns = 3\nnu = 1\nn = 1000","category":"page"},{"location":"rocket.html#System-dynamics","page":"Rocket Control","title":"System dynamics","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Note that the dyn function which defines the dynamics must be in a particular format. It must five inputs: x : The state of system at time t u : The input of system at time t t : The time t p : p is a named tuple of auzillary parameters required to define the fucntion k : k is a named tuple containing kg and kp","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"D(xh, xv, p) = p.Dc*(xv^2)*exp(-p.hc*(xh - p.xh0)/p.xh0)\ng(xh, p) = p.g0*(p.xh0/xh)^2\nfunction dyn(x, u, t, p)\n    xhn = x[2]\n    xvn = (u[1] - D(x[1], x[2], p))/x[3] - g(x[1], p)\n    xmn = -u[1]/p.c\n    return [xhn, xvn, xmn]\nend\n\nfunction integralfun(x, u, t, p)\n    return nothing\nend","category":"page"},{"location":"rocket.html#Objective-Function","page":"Rocket Control","title":"Objective Function","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"The objective function consists of running cost and a fixed cost. The running cost function also has syntax similar to the dynamics function. For the rocket example there is no running cost involved so the running cost function returns 0.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"function L(x, u, t, p)\n    return 0.0\nend","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"The Final cost function involves the contribution of final state in the objective Since we want to maximize the final height the function returns xf[1]. This is because the first state denotes the height as per our definition of the heigth function.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"function phi(xf, uf, tf, p)\n    return xf[1]\nend","category":"page"},{"location":"rocket.html#Integral-functions","page":"Rocket Control","title":"Integral functions","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Some of the problems can have integral constraints associated with them in each phase Since this problem does not have an integral constraint the integralfun will return nothing.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"function integralfun(x, u, t, p)\n    return nothing\nend","category":"page"},{"location":"rocket.html#Path-functions","page":"Rocket Control","title":"Path functions","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Some of the problems can have path constraints associated with them in each phase Since this problem does not have an path constraint the pathfun will return nothing.","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"function pathfun(x, u, t, p)\n    return nothing\nend\n\nfunction integralfun(x, u, t, p)\n    return nothing\nend","category":"page"},{"location":"rocket.html#Assignement-to-Phase-object","page":"Rocket Control","title":"Assignement to Phase object","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Each OCP must contain atleast one phase. The synatax for adding the phase to an OCP is given by","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"ph = DOC.PH(OC)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Now let us assign the various functions defined above to the phase ph that we have just created","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"ph.L = L      # Adding the running cost\nph.phi = phi  # Adding the final time cost\nph.dyn = dyn  # Add the dynamics\nph.integralfun = integralfun # Add the integral constraint function\nph.pathfun = pathfun # Add the integral constraint function\nph.n = n    # Number of points in initial mesh\nph.ns = ns  # State dimension\nph.nu = nu  # Input dimension\nph.nq = 0   # Dimension of the quadrature (integral) constraint\nph.nk = 0   # Dimension of the optimizable phase paramters\nph.np = 0   # Dimension of the path constraints\nph.p = p    # Auxillary parametrs named tuple","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Let us select some of the options for the phase","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Collocation method: Two options [\"hermite-simpson\", \"trapezoidal\"]. Default is \"hermite-simpson\"\nScale: Two options true or false","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"ph.collocation_method = \"hermite-simpson\"\nph.scale_flag = true","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Now let us set the upper bounds and lower bounds on all the variables pathconstaints and integral constraints","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"ph.limits.ll.u = [0.0]      # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.u = [p.utmax]  # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.x = [0.0, 0.0, 0.0] # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.x = [2.0, 2.0, 2.0] # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.xf = [0.3, 0, mT]      # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.xf = [2.0, 2.0, 2.0]   # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.xi = p.x0  # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.xi = p.x0  # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.ti = 0.0   # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.ti = 0.0   # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.tf = 0.2   # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.tf = 0.2   # Upper bounds on input. Vector of dimesion `ns`\nph.limits.ll.dt = 0.0     # Lower bounds on input. Vector of dimension `nu`\nph.limits.ul.dt = 0.2     # Upper bounds on input. Vector of dimesion `ns`","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"ph.limits.ll.k = [] # Lower bounds on input. Vector of dimension nu ph.limits.ul.k = [] # Upper bounds on input. Vector of dimesion ns Add the boundary constraints","category":"page"},{"location":"rocket.html#Set-intial-values","page":"Rocket Control","title":"Set intial values","text":"","category":"section"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"There are two options here \"Auto\" and \"Manual\"","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"ph.set_initial_vals = \"Auto\"\nph.tau = range(start = 0, stop = 1, length = ph.n)\nph.xinit = ones(ph.ns, ph.n)\nph.uinit = ones(ph.nu, ph.n)\nph.tfinit = ph.limits.ll.tf\nph.tiinit = ph.limits.ll.ti","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"ph.kinit  = (ph.limits.ll.k + ph.limits.ul.k)/2","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Specify initial value OC.objllim = -2.0 OC.objulim = 2.0","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"OC.psi_llim = [0.0]\nOC.psi_ulim = [0.0]","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"OC.kgllim = [0.0, 0.0, 0.0] OC.kgulim = [1.0, 1.0, 1.0]","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"OC.nkg = 0     #  Number of global parameters  Optional parameter\nOC.npsi = 1    # Optional parameter evnts\nfunction psi(ocp::DOC.OCP)\n    (;ph) = ocp\n\n    v1 = ph[1].u[:, end]\n\n    return [v1;]","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"return nothing","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"end\n\nOC.psi = psi","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Call function to setup the JuMP model for solving optimal control problem","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"DOC.setup_mpocp(OC)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Solve for the control and state","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"DOC.solve_mpocp(OC)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"DOC.solve(OC)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"solution_summary(OC.model)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"Display results","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"println(\"Objective Value: \", objective_value(OC.model))\n\nf = Figure()\nax1 = Axis(f[1,1])\nlines!(ax1, value.(ph.t), value.(ph.x[1,:]))\nax2 = Axis(f[2,1])\nlines!(ax2, value.(ph.t), value.(ph.x[2,:]))\nax3 = Axis(f[1, 2])\nlines!(ax3, value.(ph.t), value.(ph.x[3,:]))\nax4 = Axis(f[2, 2])\nlines!(ax4,value.(ph.t), value.(ph.u[1,:]))\ndisplay(f)","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"","category":"page"},{"location":"rocket.html","page":"Rocket Control","title":"Rocket Control","text":"This page was generated using Literate.jl.","category":"page"},{"location":"README.html#A-package-to-solve-multiple-phase-optimal-control-problems","page":"Introduction","title":"A package to solve multiple-phase optimal control problems","text":"","category":"section"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"An p-phase optimal control problem can be stated in the following general form. Determine the state, bf x^(p)(t) in mathbbR^n_z^(p) control bf u^(p)(t) in mathbbR^n_u^(p), initial time t_0^(p)inmathbbR, final time t_f^(p)inmathbbR, integrals, bf q^(p)inmathbbR^n_q^(p), local parameters bf k_p in mathbbR^n_k^(p)  in each phase pin1P, and the static parameters, bf k_ginmathbbR^n_kg, that minimize the cost functional ","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"J=sum_p=1^nJ_p","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"where,","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"J_p=intop_t_i^p^t_f^pL^p(bf x^(p)(t)bf u^(p)(t)t^(p)bf kbf ap) dt^p+phi(x^(p)(t_f^p)u^(p)(t_f^p)t_f^(p)bf kbf ap)","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"Note: bf ap contains all the auxillary parameters used to define various functions,  and bf k =bf k_p bf k_g is a stacked vector of phase and global parameters which can be optimized. ","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"The cost funtional J must be minimized subject to the following constraints in each phase p:","category":"page"},{"location":"README.html#Path-constraints:","page":"Introduction","title":"Path constraints:","text":"","category":"section"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"Path constraints are the constraints which the states and controls must obey at each instant t^(p) .","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"bf pf_l^(p)leqbf pathfun^(p)(bf x^p(t)bf u^p(t)t^(p)bf kbf ap)inmathbbR^n_pf^kleqbf pf_u^(p) forall t^(p)int_i^(p)t_f^(p)","category":"page"},{"location":"README.html#Integral-constraints:","page":"Introduction","title":"Integral constraints:","text":"","category":"section"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"Define: ","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"bf IF^(p)=intop_t_i^p^t_f^pbf integralfun^(p)(bf x^(p)(t)bf u^(p)(t)t^(p)bf kbf ap) dt^(p)","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"bf if_l^(p)leqbf pathfun(bf x^p(t)bf u^p(t)t^(p)bf kbf ap)inmathbbR^n_pf^kleqbf if_u^(p)","category":"page"},{"location":"README.html#Event-constraints:","page":"Introduction","title":"Event constraints:","text":"","category":"section"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"Events in time are what cause a change of phase. Event constraints represent linkages between initial times, states, inputs and final times, states, inputs between phases.","category":"page"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"bf psi_u^(p)leqbf psi(t_i^(1)t_f^(1)bf x_f^(1)bf u_f^(1)t_i^(2)t_f^(2)bf x_f^(2)bf u_f^(2)ldots t_i^(P)t_f^(P)bf x_f^(P)bf u_f^(P))inmathbbR^n_psi^(p)leqbf psi_u^(p)","category":"page"},{"location":"README.html#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"Multiple phases\nScaling\nMesh recomputation\nFlexibility in formulating problems","category":"page"},{"location":"README.html#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"README.html","page":"Introduction","title":"Introduction","text":"add https://github.com/A-C1/DirectOptimalControl.jl","category":"page"},{"location":"index.html#DirectOptimalControl.jl-Documentation","page":"DirectOptimalControl.jl Documentation","title":"DirectOptimalControl.jl Documentation","text":"","category":"section"},{"location":"index.html","page":"DirectOptimalControl.jl Documentation","title":"DirectOptimalControl.jl Documentation","text":"","category":"page"},{"location":"index.html","page":"DirectOptimalControl.jl Documentation","title":"DirectOptimalControl.jl Documentation","text":"DOC.trapezoidal(ph::DOC.PH, model::DOC.Model)","category":"page"},{"location":"index.html#DirectOptimalControl.trapezoidal-Tuple{DirectOptimalControl.PH0, Model}","page":"DirectOptimalControl.jl Documentation","title":"DirectOptimalControl.trapezoidal","text":"trapezoidal(ph, model)\n\nAdds trapezoidal collocation to model.\n\n\n\n\n\n","category":"method"}]
}
